
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/library"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
 * Metrics
 */
export type Metrics = runtime.Metrics
export type Metric<T> = runtime.Metric<T>
export type MetricHistogram = runtime.MetricHistogram
export type MetricHistogramBucket = runtime.MetricHistogramBucket

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 6.19.0
 * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
 */
export const prismaVersion: PrismaVersion = {
  client: "6.19.0",
  engine: "2ba551f319ab1df4bc874a89965d8b3641056773"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.objectEnumValues.classes.DbNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.DbNull),
  JsonNull: runtime.objectEnumValues.classes.JsonNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.JsonNull),
  AnyNull: runtime.objectEnumValues.classes.AnyNull as (new (secret: never) => typeof runtime.objectEnumValues.instances.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.objectEnumValues.instances.DbNull
/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.objectEnumValues.instances.JsonNull
/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.objectEnumValues.instances.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  User: 'User',
  SocialLogin: 'SocialLogin',
  UserSession: 'UserSession',
  Invitation: 'Invitation',
  AuthAccount: 'AuthAccount',
  Session: 'Session',
  VerificationToken: 'VerificationToken',
  ActivityLog: 'ActivityLog',
  Campus: 'Campus',
  SmallGroup: 'SmallGroup',
  GroupMember: 'GroupMember',
  GroupMeeting: 'GroupMeeting',
  GroupMeetingRotation: 'GroupMeetingRotation',
  GroupMeetingAttendance: 'GroupMeetingAttendance',
  GroupDiscussion: 'GroupDiscussion',
  GroupDiscussionReply: 'GroupDiscussionReply',
  DiscipleshipClass: 'DiscipleshipClass',
  DiscipleshipEnrollment: 'DiscipleshipEnrollment',
  Mentorship: 'Mentorship',
  MentorshipMeeting: 'MentorshipMeeting',
  Announcement: 'Announcement',
  AnnouncementRead: 'AnnouncementRead',
  Notification: 'Notification',
  MessageTemplate: 'MessageTemplate',
  ServicePlan: 'ServicePlan',
  ServicePlanItem: 'ServicePlanItem',
  ServiceAssignment: 'ServiceAssignment',
  Media: 'Media',
  Livestream: 'Livestream',
  LivestreamChat: 'LivestreamChat',
  LivestreamAnalytics: 'LivestreamAnalytics',
  Attendance: 'Attendance',
  Donation: 'Donation',
  GivingQRCode: 'GivingQRCode',
  RecurringDonation: 'RecurringDonation',
  Expense: 'Expense',
  Budget: 'Budget',
  Account: 'Account',
  Transaction: 'Transaction',
  Event: 'Event',
  EventRegistration: 'EventRegistration',
  EventCheckIn: 'EventCheckIn',
  CalendarEvent: 'CalendarEvent',
  Facility: 'Facility',
  FacilityBooking: 'FacilityBooking',
  VolunteerRole: 'VolunteerRole',
  VolunteerAssignment: 'VolunteerAssignment',
  VolunteerShift: 'VolunteerShift',
  ChildrenClass: 'ChildrenClass',
  ChildrenMinistryMember: 'ChildrenMinistryMember',
  ChildrenAttendance: 'ChildrenAttendance',
  ChildrenLesson: 'ChildrenLesson',
  YouthGroup: 'YouthGroup',
  YouthGroupMember: 'YouthGroupMember',
  YouthEvent: 'YouthEvent',
  Outreach: 'Outreach',
  OutreachParticipant: 'OutreachParticipant',
  OutreachTestimony: 'OutreachTestimony',
  CommunityProject: 'CommunityProject',
  ProjectDonation: 'ProjectDonation',
  ProjectUpdate: 'ProjectUpdate',
  Document: 'Document',
  Asset: 'Asset',
  AssetMaintenance: 'AssetMaintenance',
  Department: 'Department',
  InventoryItem: 'InventoryItem',
  InventoryTransaction: 'InventoryTransaction',
  Staff: 'Staff',
  Payroll: 'Payroll',
  Payslip: 'Payslip',
  Check: 'Check',
  GuestVisit: 'GuestVisit',
  GuestFollowUp: 'GuestFollowUp',
  Leave: 'Leave',
  PerformanceAppraisal: 'PerformanceAppraisal',
  Church: 'Church',
  ChurchSetting: 'ChurchSetting',
  CustomField: 'CustomField',
  Residence: 'Residence',
  PrayerRequest: 'PrayerRequest',
  Prayer: 'Prayer',
  PrayerRequestUpdate: 'PrayerRequestUpdate',
  Conversation: 'Conversation',
  ConversationParticipant: 'ConversationParticipant',
  Message: 'Message',
  MessageRead: 'MessageRead',
  Survey: 'Survey',
  SurveyQuestion: 'SurveyQuestion',
  SurveyResponse: 'SurveyResponse',
  SurveyResponseAnswer: 'SurveyResponseAnswer',
  MemberEngagementScore: 'MemberEngagementScore',
  Workflow: 'Workflow',
  WorkflowAction: 'WorkflowAction',
  WorkflowExecution: 'WorkflowExecution',
  WorkflowActionExecution: 'WorkflowActionExecution',
  Form: 'Form',
  FormField: 'FormField',
  FormSubmission: 'FormSubmission',
  FormSubmissionAnswer: 'FormSubmissionAnswer',
  MemberConnection: 'MemberConnection',
  CasbinRule: 'CasbinRule'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "user" | "socialLogin" | "userSession" | "invitation" | "authAccount" | "session" | "verificationToken" | "activityLog" | "campus" | "smallGroup" | "groupMember" | "groupMeeting" | "groupMeetingRotation" | "groupMeetingAttendance" | "groupDiscussion" | "groupDiscussionReply" | "discipleshipClass" | "discipleshipEnrollment" | "mentorship" | "mentorshipMeeting" | "announcement" | "announcementRead" | "notification" | "messageTemplate" | "servicePlan" | "servicePlanItem" | "serviceAssignment" | "media" | "livestream" | "livestreamChat" | "livestreamAnalytics" | "attendance" | "donation" | "givingQRCode" | "recurringDonation" | "expense" | "budget" | "account" | "transaction" | "event" | "eventRegistration" | "eventCheckIn" | "calendarEvent" | "facility" | "facilityBooking" | "volunteerRole" | "volunteerAssignment" | "volunteerShift" | "childrenClass" | "childrenMinistryMember" | "childrenAttendance" | "childrenLesson" | "youthGroup" | "youthGroupMember" | "youthEvent" | "outreach" | "outreachParticipant" | "outreachTestimony" | "communityProject" | "projectDonation" | "projectUpdate" | "document" | "asset" | "assetMaintenance" | "department" | "inventoryItem" | "inventoryTransaction" | "staff" | "payroll" | "payslip" | "check" | "guestVisit" | "guestFollowUp" | "leave" | "performanceAppraisal" | "church" | "churchSetting" | "customField" | "residence" | "prayerRequest" | "prayer" | "prayerRequestUpdate" | "conversation" | "conversationParticipant" | "message" | "messageRead" | "survey" | "surveyQuestion" | "surveyResponse" | "surveyResponseAnswer" | "memberEngagementScore" | "workflow" | "workflowAction" | "workflowExecution" | "workflowActionExecution" | "form" | "formField" | "formSubmission" | "formSubmissionAnswer" | "memberConnection" | "casbinRule"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    SocialLogin: {
      payload: Prisma.$SocialLoginPayload<ExtArgs>
      fields: Prisma.SocialLoginFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SocialLoginFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SocialLoginFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        findFirst: {
          args: Prisma.SocialLoginFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SocialLoginFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        findMany: {
          args: Prisma.SocialLoginFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>[]
        }
        create: {
          args: Prisma.SocialLoginCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        createMany: {
          args: Prisma.SocialLoginCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SocialLoginCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>[]
        }
        delete: {
          args: Prisma.SocialLoginDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        update: {
          args: Prisma.SocialLoginUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        deleteMany: {
          args: Prisma.SocialLoginDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SocialLoginUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SocialLoginUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>[]
        }
        upsert: {
          args: Prisma.SocialLoginUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SocialLoginPayload>
        }
        aggregate: {
          args: Prisma.SocialLoginAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSocialLogin>
        }
        groupBy: {
          args: Prisma.SocialLoginGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialLoginGroupByOutputType>[]
        }
        count: {
          args: Prisma.SocialLoginCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SocialLoginCountAggregateOutputType> | number
        }
      }
    }
    UserSession: {
      payload: Prisma.$UserSessionPayload<ExtArgs>
      fields: Prisma.UserSessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        findFirst: {
          args: Prisma.UserSessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        findMany: {
          args: Prisma.UserSessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        create: {
          args: Prisma.UserSessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        createMany: {
          args: Prisma.UserSessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        delete: {
          args: Prisma.UserSessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        update: {
          args: Prisma.UserSessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        deleteMany: {
          args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
        }
        upsert: {
          args: Prisma.UserSessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserSessionPayload>
        }
        aggregate: {
          args: Prisma.UserSessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserSession>
        }
        groupBy: {
          args: Prisma.UserSessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserSessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserSessionCountAggregateOutputType> | number
        }
      }
    }
    Invitation: {
      payload: Prisma.$InvitationPayload<ExtArgs>
      fields: Prisma.InvitationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InvitationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        findFirst: {
          args: Prisma.InvitationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        findMany: {
          args: Prisma.InvitationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        create: {
          args: Prisma.InvitationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        createMany: {
          args: Prisma.InvitationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        delete: {
          args: Prisma.InvitationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        update: {
          args: Prisma.InvitationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        deleteMany: {
          args: Prisma.InvitationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InvitationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>[]
        }
        upsert: {
          args: Prisma.InvitationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InvitationPayload>
        }
        aggregate: {
          args: Prisma.InvitationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInvitation>
        }
        groupBy: {
          args: Prisma.InvitationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitationGroupByOutputType>[]
        }
        count: {
          args: Prisma.InvitationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InvitationCountAggregateOutputType> | number
        }
      }
    }
    AuthAccount: {
      payload: Prisma.$AuthAccountPayload<ExtArgs>
      fields: Prisma.AuthAccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AuthAccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AuthAccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        findFirst: {
          args: Prisma.AuthAccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AuthAccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        findMany: {
          args: Prisma.AuthAccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>[]
        }
        create: {
          args: Prisma.AuthAccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        createMany: {
          args: Prisma.AuthAccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AuthAccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>[]
        }
        delete: {
          args: Prisma.AuthAccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        update: {
          args: Prisma.AuthAccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        deleteMany: {
          args: Prisma.AuthAccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AuthAccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AuthAccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>[]
        }
        upsert: {
          args: Prisma.AuthAccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AuthAccountPayload>
        }
        aggregate: {
          args: Prisma.AuthAccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAuthAccount>
        }
        groupBy: {
          args: Prisma.AuthAccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthAccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AuthAccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AuthAccountCountAggregateOutputType> | number
        }
      }
    }
    Session: {
      payload: Prisma.$SessionPayload<ExtArgs>
      fields: Prisma.SessionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SessionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findFirst: {
          args: Prisma.SessionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        findMany: {
          args: Prisma.SessionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        create: {
          args: Prisma.SessionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        createMany: {
          args: Prisma.SessionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        delete: {
          args: Prisma.SessionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        update: {
          args: Prisma.SessionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        deleteMany: {
          args: Prisma.SessionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SessionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>[]
        }
        upsert: {
          args: Prisma.SessionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SessionPayload>
        }
        aggregate: {
          args: Prisma.SessionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSession>
        }
        groupBy: {
          args: Prisma.SessionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SessionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SessionCountAggregateOutputType> | number
        }
      }
    }
    VerificationToken: {
      payload: Prisma.$VerificationTokenPayload<ExtArgs>
      fields: Prisma.VerificationTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findFirst: {
          args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        findMany: {
          args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        create: {
          args: Prisma.VerificationTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        createMany: {
          args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        delete: {
          args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        update: {
          args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        deleteMany: {
          args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
        }
        upsert: {
          args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
        }
        aggregate: {
          args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVerificationToken>
        }
        groupBy: {
          args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.VerificationTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VerificationTokenCountAggregateOutputType> | number
        }
      }
    }
    ActivityLog: {
      payload: Prisma.$ActivityLogPayload<ExtArgs>
      fields: Prisma.ActivityLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        findFirst: {
          args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        findMany: {
          args: Prisma.ActivityLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
        }
        create: {
          args: Prisma.ActivityLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        createMany: {
          args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
        }
        delete: {
          args: Prisma.ActivityLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        update: {
          args: Prisma.ActivityLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        deleteMany: {
          args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
        }
        upsert: {
          args: Prisma.ActivityLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ActivityLogPayload>
        }
        aggregate: {
          args: Prisma.ActivityLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateActivityLog>
        }
        groupBy: {
          args: Prisma.ActivityLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.ActivityLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ActivityLogCountAggregateOutputType> | number
        }
      }
    }
    Campus: {
      payload: Prisma.$CampusPayload<ExtArgs>
      fields: Prisma.CampusFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CampusFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CampusFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        findFirst: {
          args: Prisma.CampusFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CampusFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        findMany: {
          args: Prisma.CampusFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        create: {
          args: Prisma.CampusCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        createMany: {
          args: Prisma.CampusCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CampusCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        delete: {
          args: Prisma.CampusDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        update: {
          args: Prisma.CampusUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        deleteMany: {
          args: Prisma.CampusDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CampusUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CampusUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>[]
        }
        upsert: {
          args: Prisma.CampusUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CampusPayload>
        }
        aggregate: {
          args: Prisma.CampusAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCampus>
        }
        groupBy: {
          args: Prisma.CampusGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusGroupByOutputType>[]
        }
        count: {
          args: Prisma.CampusCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CampusCountAggregateOutputType> | number
        }
      }
    }
    SmallGroup: {
      payload: Prisma.$SmallGroupPayload<ExtArgs>
      fields: Prisma.SmallGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SmallGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SmallGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        findFirst: {
          args: Prisma.SmallGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SmallGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        findMany: {
          args: Prisma.SmallGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>[]
        }
        create: {
          args: Prisma.SmallGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        createMany: {
          args: Prisma.SmallGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SmallGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>[]
        }
        delete: {
          args: Prisma.SmallGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        update: {
          args: Prisma.SmallGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        deleteMany: {
          args: Prisma.SmallGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SmallGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SmallGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>[]
        }
        upsert: {
          args: Prisma.SmallGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SmallGroupPayload>
        }
        aggregate: {
          args: Prisma.SmallGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSmallGroup>
        }
        groupBy: {
          args: Prisma.SmallGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SmallGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.SmallGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SmallGroupCountAggregateOutputType> | number
        }
      }
    }
    GroupMember: {
      payload: Prisma.$GroupMemberPayload<ExtArgs>
      fields: Prisma.GroupMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        findFirst: {
          args: Prisma.GroupMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        findMany: {
          args: Prisma.GroupMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        create: {
          args: Prisma.GroupMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        createMany: {
          args: Prisma.GroupMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        delete: {
          args: Prisma.GroupMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        update: {
          args: Prisma.GroupMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        deleteMany: {
          args: Prisma.GroupMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>[]
        }
        upsert: {
          args: Prisma.GroupMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMemberPayload>
        }
        aggregate: {
          args: Prisma.GroupMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupMember>
        }
        groupBy: {
          args: Prisma.GroupMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMemberCountAggregateOutputType> | number
        }
      }
    }
    GroupMeeting: {
      payload: Prisma.$GroupMeetingPayload<ExtArgs>
      fields: Prisma.GroupMeetingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupMeetingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupMeetingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        findFirst: {
          args: Prisma.GroupMeetingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupMeetingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        findMany: {
          args: Prisma.GroupMeetingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>[]
        }
        create: {
          args: Prisma.GroupMeetingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        createMany: {
          args: Prisma.GroupMeetingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupMeetingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>[]
        }
        delete: {
          args: Prisma.GroupMeetingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        update: {
          args: Prisma.GroupMeetingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        deleteMany: {
          args: Prisma.GroupMeetingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupMeetingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupMeetingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>[]
        }
        upsert: {
          args: Prisma.GroupMeetingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingPayload>
        }
        aggregate: {
          args: Prisma.GroupMeetingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupMeeting>
        }
        groupBy: {
          args: Prisma.GroupMeetingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupMeetingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingCountAggregateOutputType> | number
        }
      }
    }
    GroupMeetingRotation: {
      payload: Prisma.$GroupMeetingRotationPayload<ExtArgs>
      fields: Prisma.GroupMeetingRotationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupMeetingRotationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupMeetingRotationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        findFirst: {
          args: Prisma.GroupMeetingRotationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupMeetingRotationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        findMany: {
          args: Prisma.GroupMeetingRotationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>[]
        }
        create: {
          args: Prisma.GroupMeetingRotationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        createMany: {
          args: Prisma.GroupMeetingRotationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupMeetingRotationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>[]
        }
        delete: {
          args: Prisma.GroupMeetingRotationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        update: {
          args: Prisma.GroupMeetingRotationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        deleteMany: {
          args: Prisma.GroupMeetingRotationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupMeetingRotationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupMeetingRotationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>[]
        }
        upsert: {
          args: Prisma.GroupMeetingRotationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingRotationPayload>
        }
        aggregate: {
          args: Prisma.GroupMeetingRotationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupMeetingRotation>
        }
        groupBy: {
          args: Prisma.GroupMeetingRotationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingRotationGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupMeetingRotationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingRotationCountAggregateOutputType> | number
        }
      }
    }
    GroupMeetingAttendance: {
      payload: Prisma.$GroupMeetingAttendancePayload<ExtArgs>
      fields: Prisma.GroupMeetingAttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupMeetingAttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupMeetingAttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        findFirst: {
          args: Prisma.GroupMeetingAttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupMeetingAttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        findMany: {
          args: Prisma.GroupMeetingAttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>[]
        }
        create: {
          args: Prisma.GroupMeetingAttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        createMany: {
          args: Prisma.GroupMeetingAttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupMeetingAttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>[]
        }
        delete: {
          args: Prisma.GroupMeetingAttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        update: {
          args: Prisma.GroupMeetingAttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        deleteMany: {
          args: Prisma.GroupMeetingAttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupMeetingAttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupMeetingAttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>[]
        }
        upsert: {
          args: Prisma.GroupMeetingAttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupMeetingAttendancePayload>
        }
        aggregate: {
          args: Prisma.GroupMeetingAttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupMeetingAttendance>
        }
        groupBy: {
          args: Prisma.GroupMeetingAttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingAttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupMeetingAttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupMeetingAttendanceCountAggregateOutputType> | number
        }
      }
    }
    GroupDiscussion: {
      payload: Prisma.$GroupDiscussionPayload<ExtArgs>
      fields: Prisma.GroupDiscussionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupDiscussionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupDiscussionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        findFirst: {
          args: Prisma.GroupDiscussionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupDiscussionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        findMany: {
          args: Prisma.GroupDiscussionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>[]
        }
        create: {
          args: Prisma.GroupDiscussionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        createMany: {
          args: Prisma.GroupDiscussionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupDiscussionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>[]
        }
        delete: {
          args: Prisma.GroupDiscussionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        update: {
          args: Prisma.GroupDiscussionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        deleteMany: {
          args: Prisma.GroupDiscussionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupDiscussionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupDiscussionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>[]
        }
        upsert: {
          args: Prisma.GroupDiscussionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionPayload>
        }
        aggregate: {
          args: Prisma.GroupDiscussionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupDiscussion>
        }
        groupBy: {
          args: Prisma.GroupDiscussionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupDiscussionGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupDiscussionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupDiscussionCountAggregateOutputType> | number
        }
      }
    }
    GroupDiscussionReply: {
      payload: Prisma.$GroupDiscussionReplyPayload<ExtArgs>
      fields: Prisma.GroupDiscussionReplyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GroupDiscussionReplyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GroupDiscussionReplyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        findFirst: {
          args: Prisma.GroupDiscussionReplyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GroupDiscussionReplyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        findMany: {
          args: Prisma.GroupDiscussionReplyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>[]
        }
        create: {
          args: Prisma.GroupDiscussionReplyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        createMany: {
          args: Prisma.GroupDiscussionReplyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GroupDiscussionReplyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>[]
        }
        delete: {
          args: Prisma.GroupDiscussionReplyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        update: {
          args: Prisma.GroupDiscussionReplyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        deleteMany: {
          args: Prisma.GroupDiscussionReplyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GroupDiscussionReplyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GroupDiscussionReplyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>[]
        }
        upsert: {
          args: Prisma.GroupDiscussionReplyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GroupDiscussionReplyPayload>
        }
        aggregate: {
          args: Prisma.GroupDiscussionReplyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGroupDiscussionReply>
        }
        groupBy: {
          args: Prisma.GroupDiscussionReplyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupDiscussionReplyGroupByOutputType>[]
        }
        count: {
          args: Prisma.GroupDiscussionReplyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GroupDiscussionReplyCountAggregateOutputType> | number
        }
      }
    }
    DiscipleshipClass: {
      payload: Prisma.$DiscipleshipClassPayload<ExtArgs>
      fields: Prisma.DiscipleshipClassFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscipleshipClassFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscipleshipClassFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        findFirst: {
          args: Prisma.DiscipleshipClassFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscipleshipClassFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        findMany: {
          args: Prisma.DiscipleshipClassFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>[]
        }
        create: {
          args: Prisma.DiscipleshipClassCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        createMany: {
          args: Prisma.DiscipleshipClassCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscipleshipClassCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>[]
        }
        delete: {
          args: Prisma.DiscipleshipClassDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        update: {
          args: Prisma.DiscipleshipClassUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        deleteMany: {
          args: Prisma.DiscipleshipClassDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscipleshipClassUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscipleshipClassUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>[]
        }
        upsert: {
          args: Prisma.DiscipleshipClassUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipClassPayload>
        }
        aggregate: {
          args: Prisma.DiscipleshipClassAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscipleshipClass>
        }
        groupBy: {
          args: Prisma.DiscipleshipClassGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscipleshipClassGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscipleshipClassCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscipleshipClassCountAggregateOutputType> | number
        }
      }
    }
    DiscipleshipEnrollment: {
      payload: Prisma.$DiscipleshipEnrollmentPayload<ExtArgs>
      fields: Prisma.DiscipleshipEnrollmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DiscipleshipEnrollmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DiscipleshipEnrollmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        findFirst: {
          args: Prisma.DiscipleshipEnrollmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DiscipleshipEnrollmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        findMany: {
          args: Prisma.DiscipleshipEnrollmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>[]
        }
        create: {
          args: Prisma.DiscipleshipEnrollmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        createMany: {
          args: Prisma.DiscipleshipEnrollmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DiscipleshipEnrollmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>[]
        }
        delete: {
          args: Prisma.DiscipleshipEnrollmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        update: {
          args: Prisma.DiscipleshipEnrollmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        deleteMany: {
          args: Prisma.DiscipleshipEnrollmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DiscipleshipEnrollmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DiscipleshipEnrollmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>[]
        }
        upsert: {
          args: Prisma.DiscipleshipEnrollmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DiscipleshipEnrollmentPayload>
        }
        aggregate: {
          args: Prisma.DiscipleshipEnrollmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDiscipleshipEnrollment>
        }
        groupBy: {
          args: Prisma.DiscipleshipEnrollmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscipleshipEnrollmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DiscipleshipEnrollmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DiscipleshipEnrollmentCountAggregateOutputType> | number
        }
      }
    }
    Mentorship: {
      payload: Prisma.$MentorshipPayload<ExtArgs>
      fields: Prisma.MentorshipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MentorshipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MentorshipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        findFirst: {
          args: Prisma.MentorshipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MentorshipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        findMany: {
          args: Prisma.MentorshipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
        }
        create: {
          args: Prisma.MentorshipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        createMany: {
          args: Prisma.MentorshipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MentorshipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
        }
        delete: {
          args: Prisma.MentorshipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        update: {
          args: Prisma.MentorshipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        deleteMany: {
          args: Prisma.MentorshipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MentorshipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MentorshipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>[]
        }
        upsert: {
          args: Prisma.MentorshipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipPayload>
        }
        aggregate: {
          args: Prisma.MentorshipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMentorship>
        }
        groupBy: {
          args: Prisma.MentorshipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentorshipGroupByOutputType>[]
        }
        count: {
          args: Prisma.MentorshipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentorshipCountAggregateOutputType> | number
        }
      }
    }
    MentorshipMeeting: {
      payload: Prisma.$MentorshipMeetingPayload<ExtArgs>
      fields: Prisma.MentorshipMeetingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MentorshipMeetingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MentorshipMeetingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        findFirst: {
          args: Prisma.MentorshipMeetingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MentorshipMeetingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        findMany: {
          args: Prisma.MentorshipMeetingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>[]
        }
        create: {
          args: Prisma.MentorshipMeetingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        createMany: {
          args: Prisma.MentorshipMeetingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MentorshipMeetingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>[]
        }
        delete: {
          args: Prisma.MentorshipMeetingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        update: {
          args: Prisma.MentorshipMeetingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        deleteMany: {
          args: Prisma.MentorshipMeetingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MentorshipMeetingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MentorshipMeetingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>[]
        }
        upsert: {
          args: Prisma.MentorshipMeetingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MentorshipMeetingPayload>
        }
        aggregate: {
          args: Prisma.MentorshipMeetingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMentorshipMeeting>
        }
        groupBy: {
          args: Prisma.MentorshipMeetingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentorshipMeetingGroupByOutputType>[]
        }
        count: {
          args: Prisma.MentorshipMeetingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MentorshipMeetingCountAggregateOutputType> | number
        }
      }
    }
    Announcement: {
      payload: Prisma.$AnnouncementPayload<ExtArgs>
      fields: Prisma.AnnouncementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findFirst: {
          args: Prisma.AnnouncementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        findMany: {
          args: Prisma.AnnouncementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        create: {
          args: Prisma.AnnouncementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        createMany: {
          args: Prisma.AnnouncementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnnouncementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        delete: {
          args: Prisma.AnnouncementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        update: {
          args: Prisma.AnnouncementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        deleteMany: {
          args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnnouncementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>[]
        }
        upsert: {
          args: Prisma.AnnouncementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementPayload>
        }
        aggregate: {
          args: Prisma.AnnouncementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncement>
        }
        groupBy: {
          args: Prisma.AnnouncementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnnouncementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementCountAggregateOutputType> | number
        }
      }
    }
    AnnouncementRead: {
      payload: Prisma.$AnnouncementReadPayload<ExtArgs>
      fields: Prisma.AnnouncementReadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AnnouncementReadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AnnouncementReadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        findFirst: {
          args: Prisma.AnnouncementReadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AnnouncementReadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        findMany: {
          args: Prisma.AnnouncementReadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
        }
        create: {
          args: Prisma.AnnouncementReadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        createMany: {
          args: Prisma.AnnouncementReadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AnnouncementReadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
        }
        delete: {
          args: Prisma.AnnouncementReadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        update: {
          args: Prisma.AnnouncementReadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        deleteMany: {
          args: Prisma.AnnouncementReadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AnnouncementReadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AnnouncementReadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>[]
        }
        upsert: {
          args: Prisma.AnnouncementReadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AnnouncementReadPayload>
        }
        aggregate: {
          args: Prisma.AnnouncementReadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAnnouncementRead>
        }
        groupBy: {
          args: Prisma.AnnouncementReadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementReadGroupByOutputType>[]
        }
        count: {
          args: Prisma.AnnouncementReadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AnnouncementReadCountAggregateOutputType> | number
        }
      }
    }
    Notification: {
      payload: Prisma.$NotificationPayload<ExtArgs>
      fields: Prisma.NotificationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotificationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findFirst: {
          args: Prisma.NotificationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        findMany: {
          args: Prisma.NotificationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        create: {
          args: Prisma.NotificationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        createMany: {
          args: Prisma.NotificationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        delete: {
          args: Prisma.NotificationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        update: {
          args: Prisma.NotificationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        deleteMany: {
          args: Prisma.NotificationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotificationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>[]
        }
        upsert: {
          args: Prisma.NotificationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotificationPayload>
        }
        aggregate: {
          args: Prisma.NotificationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotification>
        }
        groupBy: {
          args: Prisma.NotificationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotificationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotificationCountAggregateOutputType> | number
        }
      }
    }
    MessageTemplate: {
      payload: Prisma.$MessageTemplatePayload<ExtArgs>
      fields: Prisma.MessageTemplateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageTemplateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageTemplateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        findFirst: {
          args: Prisma.MessageTemplateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageTemplateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        findMany: {
          args: Prisma.MessageTemplateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
        }
        create: {
          args: Prisma.MessageTemplateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        createMany: {
          args: Prisma.MessageTemplateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageTemplateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
        }
        delete: {
          args: Prisma.MessageTemplateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        update: {
          args: Prisma.MessageTemplateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        deleteMany: {
          args: Prisma.MessageTemplateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageTemplateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageTemplateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>[]
        }
        upsert: {
          args: Prisma.MessageTemplateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageTemplatePayload>
        }
        aggregate: {
          args: Prisma.MessageTemplateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessageTemplate>
        }
        groupBy: {
          args: Prisma.MessageTemplateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageTemplateGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageTemplateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageTemplateCountAggregateOutputType> | number
        }
      }
    }
    ServicePlan: {
      payload: Prisma.$ServicePlanPayload<ExtArgs>
      fields: Prisma.ServicePlanFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServicePlanFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServicePlanFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        findFirst: {
          args: Prisma.ServicePlanFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServicePlanFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        findMany: {
          args: Prisma.ServicePlanFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>[]
        }
        create: {
          args: Prisma.ServicePlanCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        createMany: {
          args: Prisma.ServicePlanCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServicePlanCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>[]
        }
        delete: {
          args: Prisma.ServicePlanDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        update: {
          args: Prisma.ServicePlanUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        deleteMany: {
          args: Prisma.ServicePlanDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServicePlanUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServicePlanUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>[]
        }
        upsert: {
          args: Prisma.ServicePlanUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanPayload>
        }
        aggregate: {
          args: Prisma.ServicePlanAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicePlan>
        }
        groupBy: {
          args: Prisma.ServicePlanGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePlanGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServicePlanCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePlanCountAggregateOutputType> | number
        }
      }
    }
    ServicePlanItem: {
      payload: Prisma.$ServicePlanItemPayload<ExtArgs>
      fields: Prisma.ServicePlanItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServicePlanItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServicePlanItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        findFirst: {
          args: Prisma.ServicePlanItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServicePlanItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        findMany: {
          args: Prisma.ServicePlanItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>[]
        }
        create: {
          args: Prisma.ServicePlanItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        createMany: {
          args: Prisma.ServicePlanItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServicePlanItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>[]
        }
        delete: {
          args: Prisma.ServicePlanItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        update: {
          args: Prisma.ServicePlanItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        deleteMany: {
          args: Prisma.ServicePlanItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServicePlanItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServicePlanItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>[]
        }
        upsert: {
          args: Prisma.ServicePlanItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServicePlanItemPayload>
        }
        aggregate: {
          args: Prisma.ServicePlanItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServicePlanItem>
        }
        groupBy: {
          args: Prisma.ServicePlanItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePlanItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServicePlanItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServicePlanItemCountAggregateOutputType> | number
        }
      }
    }
    ServiceAssignment: {
      payload: Prisma.$ServiceAssignmentPayload<ExtArgs>
      fields: Prisma.ServiceAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ServiceAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ServiceAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        findFirst: {
          args: Prisma.ServiceAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ServiceAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        findMany: {
          args: Prisma.ServiceAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
        }
        create: {
          args: Prisma.ServiceAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        createMany: {
          args: Prisma.ServiceAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ServiceAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
        }
        delete: {
          args: Prisma.ServiceAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        update: {
          args: Prisma.ServiceAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.ServiceAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ServiceAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ServiceAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.ServiceAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ServiceAssignmentPayload>
        }
        aggregate: {
          args: Prisma.ServiceAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateServiceAssignment>
        }
        groupBy: {
          args: Prisma.ServiceAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.ServiceAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ServiceAssignmentCountAggregateOutputType> | number
        }
      }
    }
    Media: {
      payload: Prisma.$MediaPayload<ExtArgs>
      fields: Prisma.MediaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MediaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findFirst: {
          args: Prisma.MediaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        findMany: {
          args: Prisma.MediaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        create: {
          args: Prisma.MediaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        createMany: {
          args: Prisma.MediaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        delete: {
          args: Prisma.MediaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        update: {
          args: Prisma.MediaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        deleteMany: {
          args: Prisma.MediaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MediaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>[]
        }
        upsert: {
          args: Prisma.MediaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MediaPayload>
        }
        aggregate: {
          args: Prisma.MediaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMedia>
        }
        groupBy: {
          args: Prisma.MediaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaGroupByOutputType>[]
        }
        count: {
          args: Prisma.MediaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MediaCountAggregateOutputType> | number
        }
      }
    }
    Livestream: {
      payload: Prisma.$LivestreamPayload<ExtArgs>
      fields: Prisma.LivestreamFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LivestreamFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LivestreamFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        findFirst: {
          args: Prisma.LivestreamFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LivestreamFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        findMany: {
          args: Prisma.LivestreamFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>[]
        }
        create: {
          args: Prisma.LivestreamCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        createMany: {
          args: Prisma.LivestreamCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LivestreamCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>[]
        }
        delete: {
          args: Prisma.LivestreamDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        update: {
          args: Prisma.LivestreamUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        deleteMany: {
          args: Prisma.LivestreamDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LivestreamUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LivestreamUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>[]
        }
        upsert: {
          args: Prisma.LivestreamUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamPayload>
        }
        aggregate: {
          args: Prisma.LivestreamAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLivestream>
        }
        groupBy: {
          args: Prisma.LivestreamGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamGroupByOutputType>[]
        }
        count: {
          args: Prisma.LivestreamCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamCountAggregateOutputType> | number
        }
      }
    }
    LivestreamChat: {
      payload: Prisma.$LivestreamChatPayload<ExtArgs>
      fields: Prisma.LivestreamChatFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LivestreamChatFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LivestreamChatFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        findFirst: {
          args: Prisma.LivestreamChatFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LivestreamChatFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        findMany: {
          args: Prisma.LivestreamChatFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>[]
        }
        create: {
          args: Prisma.LivestreamChatCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        createMany: {
          args: Prisma.LivestreamChatCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LivestreamChatCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>[]
        }
        delete: {
          args: Prisma.LivestreamChatDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        update: {
          args: Prisma.LivestreamChatUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        deleteMany: {
          args: Prisma.LivestreamChatDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LivestreamChatUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LivestreamChatUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>[]
        }
        upsert: {
          args: Prisma.LivestreamChatUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamChatPayload>
        }
        aggregate: {
          args: Prisma.LivestreamChatAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLivestreamChat>
        }
        groupBy: {
          args: Prisma.LivestreamChatGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamChatGroupByOutputType>[]
        }
        count: {
          args: Prisma.LivestreamChatCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamChatCountAggregateOutputType> | number
        }
      }
    }
    LivestreamAnalytics: {
      payload: Prisma.$LivestreamAnalyticsPayload<ExtArgs>
      fields: Prisma.LivestreamAnalyticsFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LivestreamAnalyticsFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LivestreamAnalyticsFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        findFirst: {
          args: Prisma.LivestreamAnalyticsFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LivestreamAnalyticsFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        findMany: {
          args: Prisma.LivestreamAnalyticsFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>[]
        }
        create: {
          args: Prisma.LivestreamAnalyticsCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        createMany: {
          args: Prisma.LivestreamAnalyticsCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LivestreamAnalyticsCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>[]
        }
        delete: {
          args: Prisma.LivestreamAnalyticsDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        update: {
          args: Prisma.LivestreamAnalyticsUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        deleteMany: {
          args: Prisma.LivestreamAnalyticsDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LivestreamAnalyticsUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LivestreamAnalyticsUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>[]
        }
        upsert: {
          args: Prisma.LivestreamAnalyticsUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LivestreamAnalyticsPayload>
        }
        aggregate: {
          args: Prisma.LivestreamAnalyticsAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLivestreamAnalytics>
        }
        groupBy: {
          args: Prisma.LivestreamAnalyticsGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamAnalyticsGroupByOutputType>[]
        }
        count: {
          args: Prisma.LivestreamAnalyticsCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LivestreamAnalyticsCountAggregateOutputType> | number
        }
      }
    }
    Attendance: {
      payload: Prisma.$AttendancePayload<ExtArgs>
      fields: Prisma.AttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findFirst: {
          args: Prisma.AttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        findMany: {
          args: Prisma.AttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        create: {
          args: Prisma.AttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        createMany: {
          args: Prisma.AttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        delete: {
          args: Prisma.AttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        update: {
          args: Prisma.AttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        deleteMany: {
          args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>[]
        }
        upsert: {
          args: Prisma.AttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AttendancePayload>
        }
        aggregate: {
          args: Prisma.AttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAttendance>
        }
        groupBy: {
          args: Prisma.AttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AttendanceCountAggregateOutputType> | number
        }
      }
    }
    Donation: {
      payload: Prisma.$DonationPayload<ExtArgs>
      fields: Prisma.DonationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DonationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DonationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        findFirst: {
          args: Prisma.DonationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DonationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        findMany: {
          args: Prisma.DonationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        create: {
          args: Prisma.DonationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        createMany: {
          args: Prisma.DonationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DonationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        delete: {
          args: Prisma.DonationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        update: {
          args: Prisma.DonationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        deleteMany: {
          args: Prisma.DonationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DonationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DonationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>[]
        }
        upsert: {
          args: Prisma.DonationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DonationPayload>
        }
        aggregate: {
          args: Prisma.DonationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDonation>
        }
        groupBy: {
          args: Prisma.DonationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationGroupByOutputType>[]
        }
        count: {
          args: Prisma.DonationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DonationCountAggregateOutputType> | number
        }
      }
    }
    GivingQRCode: {
      payload: Prisma.$GivingQRCodePayload<ExtArgs>
      fields: Prisma.GivingQRCodeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GivingQRCodeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GivingQRCodeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        findFirst: {
          args: Prisma.GivingQRCodeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GivingQRCodeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        findMany: {
          args: Prisma.GivingQRCodeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>[]
        }
        create: {
          args: Prisma.GivingQRCodeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        createMany: {
          args: Prisma.GivingQRCodeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GivingQRCodeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>[]
        }
        delete: {
          args: Prisma.GivingQRCodeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        update: {
          args: Prisma.GivingQRCodeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        deleteMany: {
          args: Prisma.GivingQRCodeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GivingQRCodeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GivingQRCodeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>[]
        }
        upsert: {
          args: Prisma.GivingQRCodeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GivingQRCodePayload>
        }
        aggregate: {
          args: Prisma.GivingQRCodeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGivingQRCode>
        }
        groupBy: {
          args: Prisma.GivingQRCodeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GivingQRCodeGroupByOutputType>[]
        }
        count: {
          args: Prisma.GivingQRCodeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GivingQRCodeCountAggregateOutputType> | number
        }
      }
    }
    RecurringDonation: {
      payload: Prisma.$RecurringDonationPayload<ExtArgs>
      fields: Prisma.RecurringDonationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RecurringDonationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RecurringDonationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        findFirst: {
          args: Prisma.RecurringDonationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RecurringDonationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        findMany: {
          args: Prisma.RecurringDonationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        create: {
          args: Prisma.RecurringDonationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        createMany: {
          args: Prisma.RecurringDonationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RecurringDonationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        delete: {
          args: Prisma.RecurringDonationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        update: {
          args: Prisma.RecurringDonationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        deleteMany: {
          args: Prisma.RecurringDonationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RecurringDonationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RecurringDonationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>[]
        }
        upsert: {
          args: Prisma.RecurringDonationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RecurringDonationPayload>
        }
        aggregate: {
          args: Prisma.RecurringDonationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRecurringDonation>
        }
        groupBy: {
          args: Prisma.RecurringDonationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringDonationGroupByOutputType>[]
        }
        count: {
          args: Prisma.RecurringDonationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RecurringDonationCountAggregateOutputType> | number
        }
      }
    }
    Expense: {
      payload: Prisma.$ExpensePayload<ExtArgs>
      fields: Prisma.ExpenseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findFirst: {
          args: Prisma.ExpenseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        findMany: {
          args: Prisma.ExpenseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        create: {
          args: Prisma.ExpenseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        createMany: {
          args: Prisma.ExpenseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        delete: {
          args: Prisma.ExpenseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        update: {
          args: Prisma.ExpenseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        deleteMany: {
          args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>[]
        }
        upsert: {
          args: Prisma.ExpenseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExpensePayload>
        }
        aggregate: {
          args: Prisma.ExpenseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExpense>
        }
        groupBy: {
          args: Prisma.ExpenseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExpenseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExpenseCountAggregateOutputType> | number
        }
      }
    }
    Budget: {
      payload: Prisma.$BudgetPayload<ExtArgs>
      fields: Prisma.BudgetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BudgetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BudgetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        findFirst: {
          args: Prisma.BudgetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BudgetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        findMany: {
          args: Prisma.BudgetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        create: {
          args: Prisma.BudgetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        createMany: {
          args: Prisma.BudgetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BudgetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        delete: {
          args: Prisma.BudgetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        update: {
          args: Prisma.BudgetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        deleteMany: {
          args: Prisma.BudgetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BudgetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BudgetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>[]
        }
        upsert: {
          args: Prisma.BudgetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BudgetPayload>
        }
        aggregate: {
          args: Prisma.BudgetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBudget>
        }
        groupBy: {
          args: Prisma.BudgetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetGroupByOutputType>[]
        }
        count: {
          args: Prisma.BudgetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BudgetCountAggregateOutputType> | number
        }
      }
    }
    Account: {
      payload: Prisma.$AccountPayload<ExtArgs>
      fields: Prisma.AccountFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AccountFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findFirst: {
          args: Prisma.AccountFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        findMany: {
          args: Prisma.AccountFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        create: {
          args: Prisma.AccountCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        createMany: {
          args: Prisma.AccountCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        delete: {
          args: Prisma.AccountDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        update: {
          args: Prisma.AccountUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        deleteMany: {
          args: Prisma.AccountDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AccountUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>[]
        }
        upsert: {
          args: Prisma.AccountUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AccountPayload>
        }
        aggregate: {
          args: Prisma.AccountAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAccount>
        }
        groupBy: {
          args: Prisma.AccountGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountGroupByOutputType>[]
        }
        count: {
          args: Prisma.AccountCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AccountCountAggregateOutputType> | number
        }
      }
    }
    Transaction: {
      payload: Prisma.$TransactionPayload<ExtArgs>
      fields: Prisma.TransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findFirst: {
          args: Prisma.TransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        findMany: {
          args: Prisma.TransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        create: {
          args: Prisma.TransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        createMany: {
          args: Prisma.TransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        delete: {
          args: Prisma.TransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        update: {
          args: Prisma.TransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        deleteMany: {
          args: Prisma.TransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>[]
        }
        upsert: {
          args: Prisma.TransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TransactionPayload>
        }
        aggregate: {
          args: Prisma.TransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTransaction>
        }
        groupBy: {
          args: Prisma.TransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.TransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TransactionCountAggregateOutputType> | number
        }
      }
    }
    Event: {
      payload: Prisma.$EventPayload<ExtArgs>
      fields: Prisma.EventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findFirst: {
          args: Prisma.EventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        findMany: {
          args: Prisma.EventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        create: {
          args: Prisma.EventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        createMany: {
          args: Prisma.EventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        delete: {
          args: Prisma.EventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        update: {
          args: Prisma.EventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        deleteMany: {
          args: Prisma.EventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>[]
        }
        upsert: {
          args: Prisma.EventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventPayload>
        }
        aggregate: {
          args: Prisma.EventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEvent>
        }
        groupBy: {
          args: Prisma.EventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCountAggregateOutputType> | number
        }
      }
    }
    EventRegistration: {
      payload: Prisma.$EventRegistrationPayload<ExtArgs>
      fields: Prisma.EventRegistrationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findFirst: {
          args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        findMany: {
          args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        create: {
          args: Prisma.EventRegistrationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        createMany: {
          args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventRegistrationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        delete: {
          args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        update: {
          args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        deleteMany: {
          args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventRegistrationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
        }
        upsert: {
          args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
        }
        aggregate: {
          args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventRegistration>
        }
        groupBy: {
          args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventRegistrationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventRegistrationCountAggregateOutputType> | number
        }
      }
    }
    EventCheckIn: {
      payload: Prisma.$EventCheckInPayload<ExtArgs>
      fields: Prisma.EventCheckInFieldRefs
      operations: {
        findUnique: {
          args: Prisma.EventCheckInFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.EventCheckInFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        findFirst: {
          args: Prisma.EventCheckInFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.EventCheckInFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        findMany: {
          args: Prisma.EventCheckInFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>[]
        }
        create: {
          args: Prisma.EventCheckInCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        createMany: {
          args: Prisma.EventCheckInCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.EventCheckInCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>[]
        }
        delete: {
          args: Prisma.EventCheckInDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        update: {
          args: Prisma.EventCheckInUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        deleteMany: {
          args: Prisma.EventCheckInDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.EventCheckInUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.EventCheckInUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>[]
        }
        upsert: {
          args: Prisma.EventCheckInUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$EventCheckInPayload>
        }
        aggregate: {
          args: Prisma.EventCheckInAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateEventCheckIn>
        }
        groupBy: {
          args: Prisma.EventCheckInGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCheckInGroupByOutputType>[]
        }
        count: {
          args: Prisma.EventCheckInCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.EventCheckInCountAggregateOutputType> | number
        }
      }
    }
    CalendarEvent: {
      payload: Prisma.$CalendarEventPayload<ExtArgs>
      fields: Prisma.CalendarEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CalendarEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CalendarEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        findFirst: {
          args: Prisma.CalendarEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CalendarEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        findMany: {
          args: Prisma.CalendarEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
        }
        create: {
          args: Prisma.CalendarEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        createMany: {
          args: Prisma.CalendarEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CalendarEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
        }
        delete: {
          args: Prisma.CalendarEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        update: {
          args: Prisma.CalendarEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        deleteMany: {
          args: Prisma.CalendarEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CalendarEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CalendarEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>[]
        }
        upsert: {
          args: Prisma.CalendarEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarEventPayload>
        }
        aggregate: {
          args: Prisma.CalendarEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCalendarEvent>
        }
        groupBy: {
          args: Prisma.CalendarEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.CalendarEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarEventCountAggregateOutputType> | number
        }
      }
    }
    Facility: {
      payload: Prisma.$FacilityPayload<ExtArgs>
      fields: Prisma.FacilityFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        findFirst: {
          args: Prisma.FacilityFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        findMany: {
          args: Prisma.FacilityFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        create: {
          args: Prisma.FacilityCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        createMany: {
          args: Prisma.FacilityCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        delete: {
          args: Prisma.FacilityDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        update: {
          args: Prisma.FacilityUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        deleteMany: {
          args: Prisma.FacilityDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>[]
        }
        upsert: {
          args: Prisma.FacilityUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityPayload>
        }
        aggregate: {
          args: Prisma.FacilityAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacility>
        }
        groupBy: {
          args: Prisma.FacilityGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityCountAggregateOutputType> | number
        }
      }
    }
    FacilityBooking: {
      payload: Prisma.$FacilityBookingPayload<ExtArgs>
      fields: Prisma.FacilityBookingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FacilityBookingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FacilityBookingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        findFirst: {
          args: Prisma.FacilityBookingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FacilityBookingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        findMany: {
          args: Prisma.FacilityBookingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        create: {
          args: Prisma.FacilityBookingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        createMany: {
          args: Prisma.FacilityBookingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FacilityBookingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        delete: {
          args: Prisma.FacilityBookingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        update: {
          args: Prisma.FacilityBookingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        deleteMany: {
          args: Prisma.FacilityBookingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FacilityBookingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FacilityBookingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[]
        }
        upsert: {
          args: Prisma.FacilityBookingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FacilityBookingPayload>
        }
        aggregate: {
          args: Prisma.FacilityBookingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFacilityBooking>
        }
        groupBy: {
          args: Prisma.FacilityBookingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityBookingGroupByOutputType>[]
        }
        count: {
          args: Prisma.FacilityBookingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FacilityBookingCountAggregateOutputType> | number
        }
      }
    }
    VolunteerRole: {
      payload: Prisma.$VolunteerRolePayload<ExtArgs>
      fields: Prisma.VolunteerRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        findFirst: {
          args: Prisma.VolunteerRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        findMany: {
          args: Prisma.VolunteerRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        create: {
          args: Prisma.VolunteerRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        createMany: {
          args: Prisma.VolunteerRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        delete: {
          args: Prisma.VolunteerRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        update: {
          args: Prisma.VolunteerRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        deleteMany: {
          args: Prisma.VolunteerRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>[]
        }
        upsert: {
          args: Prisma.VolunteerRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerRolePayload>
        }
        aggregate: {
          args: Prisma.VolunteerRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerRole>
        }
        groupBy: {
          args: Prisma.VolunteerRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerRoleCountAggregateOutputType> | number
        }
      }
    }
    VolunteerAssignment: {
      payload: Prisma.$VolunteerAssignmentPayload<ExtArgs>
      fields: Prisma.VolunteerAssignmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerAssignmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerAssignmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        findFirst: {
          args: Prisma.VolunteerAssignmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerAssignmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        findMany: {
          args: Prisma.VolunteerAssignmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        create: {
          args: Prisma.VolunteerAssignmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        createMany: {
          args: Prisma.VolunteerAssignmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerAssignmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        delete: {
          args: Prisma.VolunteerAssignmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        update: {
          args: Prisma.VolunteerAssignmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerAssignmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerAssignmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerAssignmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerAssignmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerAssignmentPayload>
        }
        aggregate: {
          args: Prisma.VolunteerAssignmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerAssignment>
        }
        groupBy: {
          args: Prisma.VolunteerAssignmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAssignmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerAssignmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerAssignmentCountAggregateOutputType> | number
        }
      }
    }
    VolunteerShift: {
      payload: Prisma.$VolunteerShiftPayload<ExtArgs>
      fields: Prisma.VolunteerShiftFieldRefs
      operations: {
        findUnique: {
          args: Prisma.VolunteerShiftFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.VolunteerShiftFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        findFirst: {
          args: Prisma.VolunteerShiftFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.VolunteerShiftFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        findMany: {
          args: Prisma.VolunteerShiftFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        create: {
          args: Prisma.VolunteerShiftCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        createMany: {
          args: Prisma.VolunteerShiftCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.VolunteerShiftCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        delete: {
          args: Prisma.VolunteerShiftDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        update: {
          args: Prisma.VolunteerShiftUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        deleteMany: {
          args: Prisma.VolunteerShiftDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.VolunteerShiftUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.VolunteerShiftUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>[]
        }
        upsert: {
          args: Prisma.VolunteerShiftUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$VolunteerShiftPayload>
        }
        aggregate: {
          args: Prisma.VolunteerShiftAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateVolunteerShift>
        }
        groupBy: {
          args: Prisma.VolunteerShiftGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftGroupByOutputType>[]
        }
        count: {
          args: Prisma.VolunteerShiftCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.VolunteerShiftCountAggregateOutputType> | number
        }
      }
    }
    ChildrenClass: {
      payload: Prisma.$ChildrenClassPayload<ExtArgs>
      fields: Prisma.ChildrenClassFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChildrenClassFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChildrenClassFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        findFirst: {
          args: Prisma.ChildrenClassFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChildrenClassFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        findMany: {
          args: Prisma.ChildrenClassFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>[]
        }
        create: {
          args: Prisma.ChildrenClassCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        createMany: {
          args: Prisma.ChildrenClassCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChildrenClassCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>[]
        }
        delete: {
          args: Prisma.ChildrenClassDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        update: {
          args: Prisma.ChildrenClassUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        deleteMany: {
          args: Prisma.ChildrenClassDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChildrenClassUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChildrenClassUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>[]
        }
        upsert: {
          args: Prisma.ChildrenClassUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenClassPayload>
        }
        aggregate: {
          args: Prisma.ChildrenClassAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChildrenClass>
        }
        groupBy: {
          args: Prisma.ChildrenClassGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenClassGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChildrenClassCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenClassCountAggregateOutputType> | number
        }
      }
    }
    ChildrenMinistryMember: {
      payload: Prisma.$ChildrenMinistryMemberPayload<ExtArgs>
      fields: Prisma.ChildrenMinistryMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChildrenMinistryMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChildrenMinistryMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        findFirst: {
          args: Prisma.ChildrenMinistryMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChildrenMinistryMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        findMany: {
          args: Prisma.ChildrenMinistryMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>[]
        }
        create: {
          args: Prisma.ChildrenMinistryMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        createMany: {
          args: Prisma.ChildrenMinistryMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChildrenMinistryMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>[]
        }
        delete: {
          args: Prisma.ChildrenMinistryMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        update: {
          args: Prisma.ChildrenMinistryMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        deleteMany: {
          args: Prisma.ChildrenMinistryMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChildrenMinistryMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChildrenMinistryMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>[]
        }
        upsert: {
          args: Prisma.ChildrenMinistryMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenMinistryMemberPayload>
        }
        aggregate: {
          args: Prisma.ChildrenMinistryMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChildrenMinistryMember>
        }
        groupBy: {
          args: Prisma.ChildrenMinistryMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenMinistryMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChildrenMinistryMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenMinistryMemberCountAggregateOutputType> | number
        }
      }
    }
    ChildrenAttendance: {
      payload: Prisma.$ChildrenAttendancePayload<ExtArgs>
      fields: Prisma.ChildrenAttendanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChildrenAttendanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChildrenAttendanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        findFirst: {
          args: Prisma.ChildrenAttendanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChildrenAttendanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        findMany: {
          args: Prisma.ChildrenAttendanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>[]
        }
        create: {
          args: Prisma.ChildrenAttendanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        createMany: {
          args: Prisma.ChildrenAttendanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChildrenAttendanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>[]
        }
        delete: {
          args: Prisma.ChildrenAttendanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        update: {
          args: Prisma.ChildrenAttendanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        deleteMany: {
          args: Prisma.ChildrenAttendanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChildrenAttendanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChildrenAttendanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>[]
        }
        upsert: {
          args: Prisma.ChildrenAttendanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenAttendancePayload>
        }
        aggregate: {
          args: Prisma.ChildrenAttendanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChildrenAttendance>
        }
        groupBy: {
          args: Prisma.ChildrenAttendanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenAttendanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChildrenAttendanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenAttendanceCountAggregateOutputType> | number
        }
      }
    }
    ChildrenLesson: {
      payload: Prisma.$ChildrenLessonPayload<ExtArgs>
      fields: Prisma.ChildrenLessonFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChildrenLessonFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChildrenLessonFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        findFirst: {
          args: Prisma.ChildrenLessonFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChildrenLessonFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        findMany: {
          args: Prisma.ChildrenLessonFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>[]
        }
        create: {
          args: Prisma.ChildrenLessonCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        createMany: {
          args: Prisma.ChildrenLessonCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChildrenLessonCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>[]
        }
        delete: {
          args: Prisma.ChildrenLessonDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        update: {
          args: Prisma.ChildrenLessonUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        deleteMany: {
          args: Prisma.ChildrenLessonDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChildrenLessonUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChildrenLessonUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>[]
        }
        upsert: {
          args: Prisma.ChildrenLessonUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChildrenLessonPayload>
        }
        aggregate: {
          args: Prisma.ChildrenLessonAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChildrenLesson>
        }
        groupBy: {
          args: Prisma.ChildrenLessonGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenLessonGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChildrenLessonCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChildrenLessonCountAggregateOutputType> | number
        }
      }
    }
    YouthGroup: {
      payload: Prisma.$YouthGroupPayload<ExtArgs>
      fields: Prisma.YouthGroupFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YouthGroupFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YouthGroupFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        findFirst: {
          args: Prisma.YouthGroupFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YouthGroupFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        findMany: {
          args: Prisma.YouthGroupFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>[]
        }
        create: {
          args: Prisma.YouthGroupCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        createMany: {
          args: Prisma.YouthGroupCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.YouthGroupCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>[]
        }
        delete: {
          args: Prisma.YouthGroupDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        update: {
          args: Prisma.YouthGroupUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        deleteMany: {
          args: Prisma.YouthGroupDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YouthGroupUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.YouthGroupUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>[]
        }
        upsert: {
          args: Prisma.YouthGroupUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupPayload>
        }
        aggregate: {
          args: Prisma.YouthGroupAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYouthGroup>
        }
        groupBy: {
          args: Prisma.YouthGroupGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthGroupGroupByOutputType>[]
        }
        count: {
          args: Prisma.YouthGroupCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthGroupCountAggregateOutputType> | number
        }
      }
    }
    YouthGroupMember: {
      payload: Prisma.$YouthGroupMemberPayload<ExtArgs>
      fields: Prisma.YouthGroupMemberFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YouthGroupMemberFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YouthGroupMemberFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        findFirst: {
          args: Prisma.YouthGroupMemberFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YouthGroupMemberFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        findMany: {
          args: Prisma.YouthGroupMemberFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>[]
        }
        create: {
          args: Prisma.YouthGroupMemberCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        createMany: {
          args: Prisma.YouthGroupMemberCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.YouthGroupMemberCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>[]
        }
        delete: {
          args: Prisma.YouthGroupMemberDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        update: {
          args: Prisma.YouthGroupMemberUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        deleteMany: {
          args: Prisma.YouthGroupMemberDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YouthGroupMemberUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.YouthGroupMemberUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>[]
        }
        upsert: {
          args: Prisma.YouthGroupMemberUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthGroupMemberPayload>
        }
        aggregate: {
          args: Prisma.YouthGroupMemberAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYouthGroupMember>
        }
        groupBy: {
          args: Prisma.YouthGroupMemberGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthGroupMemberGroupByOutputType>[]
        }
        count: {
          args: Prisma.YouthGroupMemberCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthGroupMemberCountAggregateOutputType> | number
        }
      }
    }
    YouthEvent: {
      payload: Prisma.$YouthEventPayload<ExtArgs>
      fields: Prisma.YouthEventFieldRefs
      operations: {
        findUnique: {
          args: Prisma.YouthEventFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.YouthEventFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        findFirst: {
          args: Prisma.YouthEventFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.YouthEventFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        findMany: {
          args: Prisma.YouthEventFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>[]
        }
        create: {
          args: Prisma.YouthEventCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        createMany: {
          args: Prisma.YouthEventCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.YouthEventCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>[]
        }
        delete: {
          args: Prisma.YouthEventDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        update: {
          args: Prisma.YouthEventUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        deleteMany: {
          args: Prisma.YouthEventDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.YouthEventUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.YouthEventUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>[]
        }
        upsert: {
          args: Prisma.YouthEventUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$YouthEventPayload>
        }
        aggregate: {
          args: Prisma.YouthEventAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateYouthEvent>
        }
        groupBy: {
          args: Prisma.YouthEventGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthEventGroupByOutputType>[]
        }
        count: {
          args: Prisma.YouthEventCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.YouthEventCountAggregateOutputType> | number
        }
      }
    }
    Outreach: {
      payload: Prisma.$OutreachPayload<ExtArgs>
      fields: Prisma.OutreachFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OutreachFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OutreachFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        findFirst: {
          args: Prisma.OutreachFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OutreachFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        findMany: {
          args: Prisma.OutreachFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>[]
        }
        create: {
          args: Prisma.OutreachCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        createMany: {
          args: Prisma.OutreachCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OutreachCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>[]
        }
        delete: {
          args: Prisma.OutreachDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        update: {
          args: Prisma.OutreachUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        deleteMany: {
          args: Prisma.OutreachDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OutreachUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OutreachUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>[]
        }
        upsert: {
          args: Prisma.OutreachUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachPayload>
        }
        aggregate: {
          args: Prisma.OutreachAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOutreach>
        }
        groupBy: {
          args: Prisma.OutreachGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachGroupByOutputType>[]
        }
        count: {
          args: Prisma.OutreachCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachCountAggregateOutputType> | number
        }
      }
    }
    OutreachParticipant: {
      payload: Prisma.$OutreachParticipantPayload<ExtArgs>
      fields: Prisma.OutreachParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OutreachParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OutreachParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        findFirst: {
          args: Prisma.OutreachParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OutreachParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        findMany: {
          args: Prisma.OutreachParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>[]
        }
        create: {
          args: Prisma.OutreachParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        createMany: {
          args: Prisma.OutreachParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OutreachParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>[]
        }
        delete: {
          args: Prisma.OutreachParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        update: {
          args: Prisma.OutreachParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        deleteMany: {
          args: Prisma.OutreachParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OutreachParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OutreachParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>[]
        }
        upsert: {
          args: Prisma.OutreachParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachParticipantPayload>
        }
        aggregate: {
          args: Prisma.OutreachParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOutreachParticipant>
        }
        groupBy: {
          args: Prisma.OutreachParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.OutreachParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachParticipantCountAggregateOutputType> | number
        }
      }
    }
    OutreachTestimony: {
      payload: Prisma.$OutreachTestimonyPayload<ExtArgs>
      fields: Prisma.OutreachTestimonyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OutreachTestimonyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OutreachTestimonyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        findFirst: {
          args: Prisma.OutreachTestimonyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OutreachTestimonyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        findMany: {
          args: Prisma.OutreachTestimonyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>[]
        }
        create: {
          args: Prisma.OutreachTestimonyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        createMany: {
          args: Prisma.OutreachTestimonyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OutreachTestimonyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>[]
        }
        delete: {
          args: Prisma.OutreachTestimonyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        update: {
          args: Prisma.OutreachTestimonyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        deleteMany: {
          args: Prisma.OutreachTestimonyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OutreachTestimonyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OutreachTestimonyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>[]
        }
        upsert: {
          args: Prisma.OutreachTestimonyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutreachTestimonyPayload>
        }
        aggregate: {
          args: Prisma.OutreachTestimonyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOutreachTestimony>
        }
        groupBy: {
          args: Prisma.OutreachTestimonyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachTestimonyGroupByOutputType>[]
        }
        count: {
          args: Prisma.OutreachTestimonyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutreachTestimonyCountAggregateOutputType> | number
        }
      }
    }
    CommunityProject: {
      payload: Prisma.$CommunityProjectPayload<ExtArgs>
      fields: Prisma.CommunityProjectFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CommunityProjectFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CommunityProjectFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        findFirst: {
          args: Prisma.CommunityProjectFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CommunityProjectFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        findMany: {
          args: Prisma.CommunityProjectFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>[]
        }
        create: {
          args: Prisma.CommunityProjectCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        createMany: {
          args: Prisma.CommunityProjectCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CommunityProjectCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>[]
        }
        delete: {
          args: Prisma.CommunityProjectDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        update: {
          args: Prisma.CommunityProjectUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        deleteMany: {
          args: Prisma.CommunityProjectDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CommunityProjectUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CommunityProjectUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>[]
        }
        upsert: {
          args: Prisma.CommunityProjectUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CommunityProjectPayload>
        }
        aggregate: {
          args: Prisma.CommunityProjectAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCommunityProject>
        }
        groupBy: {
          args: Prisma.CommunityProjectGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunityProjectGroupByOutputType>[]
        }
        count: {
          args: Prisma.CommunityProjectCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CommunityProjectCountAggregateOutputType> | number
        }
      }
    }
    ProjectDonation: {
      payload: Prisma.$ProjectDonationPayload<ExtArgs>
      fields: Prisma.ProjectDonationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectDonationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectDonationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        findFirst: {
          args: Prisma.ProjectDonationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectDonationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        findMany: {
          args: Prisma.ProjectDonationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
        }
        create: {
          args: Prisma.ProjectDonationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        createMany: {
          args: Prisma.ProjectDonationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectDonationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
        }
        delete: {
          args: Prisma.ProjectDonationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        update: {
          args: Prisma.ProjectDonationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        deleteMany: {
          args: Prisma.ProjectDonationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectDonationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectDonationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>[]
        }
        upsert: {
          args: Prisma.ProjectDonationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectDonationPayload>
        }
        aggregate: {
          args: Prisma.ProjectDonationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectDonation>
        }
        groupBy: {
          args: Prisma.ProjectDonationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectDonationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectDonationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectDonationCountAggregateOutputType> | number
        }
      }
    }
    ProjectUpdate: {
      payload: Prisma.$ProjectUpdatePayload<ExtArgs>
      fields: Prisma.ProjectUpdateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProjectUpdateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        findFirst: {
          args: Prisma.ProjectUpdateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProjectUpdateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        findMany: {
          args: Prisma.ProjectUpdateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
        }
        create: {
          args: Prisma.ProjectUpdateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        createMany: {
          args: Prisma.ProjectUpdateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProjectUpdateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
        }
        delete: {
          args: Prisma.ProjectUpdateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        update: {
          args: Prisma.ProjectUpdateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        deleteMany: {
          args: Prisma.ProjectUpdateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProjectUpdateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
        }
        upsert: {
          args: Prisma.ProjectUpdateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
        }
        aggregate: {
          args: Prisma.ProjectUpdateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProjectUpdate>
        }
        groupBy: {
          args: Prisma.ProjectUpdateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectUpdateGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProjectUpdateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProjectUpdateCountAggregateOutputType> | number
        }
      }
    }
    Document: {
      payload: Prisma.$DocumentPayload<ExtArgs>
      fields: Prisma.DocumentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DocumentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findFirst: {
          args: Prisma.DocumentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        findMany: {
          args: Prisma.DocumentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        create: {
          args: Prisma.DocumentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        createMany: {
          args: Prisma.DocumentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        delete: {
          args: Prisma.DocumentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        update: {
          args: Prisma.DocumentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        deleteMany: {
          args: Prisma.DocumentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DocumentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>[]
        }
        upsert: {
          args: Prisma.DocumentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DocumentPayload>
        }
        aggregate: {
          args: Prisma.DocumentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDocument>
        }
        groupBy: {
          args: Prisma.DocumentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DocumentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DocumentCountAggregateOutputType> | number
        }
      }
    }
    Asset: {
      payload: Prisma.$AssetPayload<ExtArgs>
      fields: Prisma.AssetFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findFirst: {
          args: Prisma.AssetFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        findMany: {
          args: Prisma.AssetFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        create: {
          args: Prisma.AssetCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        createMany: {
          args: Prisma.AssetCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        delete: {
          args: Prisma.AssetDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        update: {
          args: Prisma.AssetUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        deleteMany: {
          args: Prisma.AssetDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>[]
        }
        upsert: {
          args: Prisma.AssetUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetPayload>
        }
        aggregate: {
          args: Prisma.AssetAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAsset>
        }
        groupBy: {
          args: Prisma.AssetGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetCountAggregateOutputType> | number
        }
      }
    }
    AssetMaintenance: {
      payload: Prisma.$AssetMaintenancePayload<ExtArgs>
      fields: Prisma.AssetMaintenanceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AssetMaintenanceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AssetMaintenanceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        findFirst: {
          args: Prisma.AssetMaintenanceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AssetMaintenanceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        findMany: {
          args: Prisma.AssetMaintenanceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>[]
        }
        create: {
          args: Prisma.AssetMaintenanceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        createMany: {
          args: Prisma.AssetMaintenanceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AssetMaintenanceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>[]
        }
        delete: {
          args: Prisma.AssetMaintenanceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        update: {
          args: Prisma.AssetMaintenanceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        deleteMany: {
          args: Prisma.AssetMaintenanceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AssetMaintenanceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AssetMaintenanceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>[]
        }
        upsert: {
          args: Prisma.AssetMaintenanceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AssetMaintenancePayload>
        }
        aggregate: {
          args: Prisma.AssetMaintenanceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAssetMaintenance>
        }
        groupBy: {
          args: Prisma.AssetMaintenanceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetMaintenanceGroupByOutputType>[]
        }
        count: {
          args: Prisma.AssetMaintenanceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AssetMaintenanceCountAggregateOutputType> | number
        }
      }
    }
    Department: {
      payload: Prisma.$DepartmentPayload<ExtArgs>
      fields: Prisma.DepartmentFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findFirst: {
          args: Prisma.DepartmentFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        findMany: {
          args: Prisma.DepartmentFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        create: {
          args: Prisma.DepartmentCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        createMany: {
          args: Prisma.DepartmentCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        delete: {
          args: Prisma.DepartmentDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        update: {
          args: Prisma.DepartmentUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        deleteMany: {
          args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
        }
        upsert: {
          args: Prisma.DepartmentUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DepartmentPayload>
        }
        aggregate: {
          args: Prisma.DepartmentAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDepartment>
        }
        groupBy: {
          args: Prisma.DepartmentGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentGroupByOutputType>[]
        }
        count: {
          args: Prisma.DepartmentCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DepartmentCountAggregateOutputType> | number
        }
      }
    }
    InventoryItem: {
      payload: Prisma.$InventoryItemPayload<ExtArgs>
      fields: Prisma.InventoryItemFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findFirst: {
          args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        findMany: {
          args: Prisma.InventoryItemFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        create: {
          args: Prisma.InventoryItemCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        createMany: {
          args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        delete: {
          args: Prisma.InventoryItemDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        update: {
          args: Prisma.InventoryItemUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        deleteMany: {
          args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
        }
        upsert: {
          args: Prisma.InventoryItemUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryItemPayload>
        }
        aggregate: {
          args: Prisma.InventoryItemAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryItem>
        }
        groupBy: {
          args: Prisma.InventoryItemGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryItemCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryItemCountAggregateOutputType> | number
        }
      }
    }
    InventoryTransaction: {
      payload: Prisma.$InventoryTransactionPayload<ExtArgs>
      fields: Prisma.InventoryTransactionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        findFirst: {
          args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        findMany: {
          args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
        }
        create: {
          args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        createMany: {
          args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InventoryTransactionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
        }
        delete: {
          args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        update: {
          args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        deleteMany: {
          args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
        }
        upsert: {
          args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
        }
        aggregate: {
          args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInventoryTransaction>
        }
        groupBy: {
          args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryTransactionGroupByOutputType>[]
        }
        count: {
          args: Prisma.InventoryTransactionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InventoryTransactionCountAggregateOutputType> | number
        }
      }
    }
    Staff: {
      payload: Prisma.$StaffPayload<ExtArgs>
      fields: Prisma.StaffFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StaffFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StaffFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        findFirst: {
          args: Prisma.StaffFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StaffFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        findMany: {
          args: Prisma.StaffFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[]
        }
        create: {
          args: Prisma.StaffCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        createMany: {
          args: Prisma.StaffCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StaffCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[]
        }
        delete: {
          args: Prisma.StaffDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        update: {
          args: Prisma.StaffUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        deleteMany: {
          args: Prisma.StaffDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StaffUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StaffUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>[]
        }
        upsert: {
          args: Prisma.StaffUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StaffPayload>
        }
        aggregate: {
          args: Prisma.StaffAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStaff>
        }
        groupBy: {
          args: Prisma.StaffGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffGroupByOutputType>[]
        }
        count: {
          args: Prisma.StaffCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StaffCountAggregateOutputType> | number
        }
      }
    }
    Payroll: {
      payload: Prisma.$PayrollPayload<ExtArgs>
      fields: Prisma.PayrollFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayrollFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findFirst: {
          args: Prisma.PayrollFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        findMany: {
          args: Prisma.PayrollFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        create: {
          args: Prisma.PayrollCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        createMany: {
          args: Prisma.PayrollCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        delete: {
          args: Prisma.PayrollDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        update: {
          args: Prisma.PayrollUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        deleteMany: {
          args: Prisma.PayrollDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayrollUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>[]
        }
        upsert: {
          args: Prisma.PayrollUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayrollPayload>
        }
        aggregate: {
          args: Prisma.PayrollAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayroll>
        }
        groupBy: {
          args: Prisma.PayrollGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayrollCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayrollCountAggregateOutputType> | number
        }
      }
    }
    Payslip: {
      payload: Prisma.$PayslipPayload<ExtArgs>
      fields: Prisma.PayslipFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PayslipFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PayslipFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        findFirst: {
          args: Prisma.PayslipFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PayslipFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        findMany: {
          args: Prisma.PayslipFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        create: {
          args: Prisma.PayslipCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        createMany: {
          args: Prisma.PayslipCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PayslipCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        delete: {
          args: Prisma.PayslipDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        update: {
          args: Prisma.PayslipUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        deleteMany: {
          args: Prisma.PayslipDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PayslipUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PayslipUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>[]
        }
        upsert: {
          args: Prisma.PayslipUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PayslipPayload>
        }
        aggregate: {
          args: Prisma.PayslipAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePayslip>
        }
        groupBy: {
          args: Prisma.PayslipGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayslipGroupByOutputType>[]
        }
        count: {
          args: Prisma.PayslipCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PayslipCountAggregateOutputType> | number
        }
      }
    }
    Check: {
      payload: Prisma.$CheckPayload<ExtArgs>
      fields: Prisma.CheckFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CheckFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CheckFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        findFirst: {
          args: Prisma.CheckFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CheckFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        findMany: {
          args: Prisma.CheckFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>[]
        }
        create: {
          args: Prisma.CheckCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        createMany: {
          args: Prisma.CheckCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CheckCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>[]
        }
        delete: {
          args: Prisma.CheckDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        update: {
          args: Prisma.CheckUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        deleteMany: {
          args: Prisma.CheckDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CheckUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CheckUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>[]
        }
        upsert: {
          args: Prisma.CheckUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CheckPayload>
        }
        aggregate: {
          args: Prisma.CheckAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCheck>
        }
        groupBy: {
          args: Prisma.CheckGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CheckGroupByOutputType>[]
        }
        count: {
          args: Prisma.CheckCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CheckCountAggregateOutputType> | number
        }
      }
    }
    GuestVisit: {
      payload: Prisma.$GuestVisitPayload<ExtArgs>
      fields: Prisma.GuestVisitFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GuestVisitFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GuestVisitFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        findFirst: {
          args: Prisma.GuestVisitFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GuestVisitFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        findMany: {
          args: Prisma.GuestVisitFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>[]
        }
        create: {
          args: Prisma.GuestVisitCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        createMany: {
          args: Prisma.GuestVisitCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GuestVisitCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>[]
        }
        delete: {
          args: Prisma.GuestVisitDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        update: {
          args: Prisma.GuestVisitUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        deleteMany: {
          args: Prisma.GuestVisitDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GuestVisitUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GuestVisitUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>[]
        }
        upsert: {
          args: Prisma.GuestVisitUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestVisitPayload>
        }
        aggregate: {
          args: Prisma.GuestVisitAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGuestVisit>
        }
        groupBy: {
          args: Prisma.GuestVisitGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestVisitGroupByOutputType>[]
        }
        count: {
          args: Prisma.GuestVisitCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestVisitCountAggregateOutputType> | number
        }
      }
    }
    GuestFollowUp: {
      payload: Prisma.$GuestFollowUpPayload<ExtArgs>
      fields: Prisma.GuestFollowUpFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GuestFollowUpFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GuestFollowUpFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        findFirst: {
          args: Prisma.GuestFollowUpFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GuestFollowUpFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        findMany: {
          args: Prisma.GuestFollowUpFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>[]
        }
        create: {
          args: Prisma.GuestFollowUpCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        createMany: {
          args: Prisma.GuestFollowUpCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GuestFollowUpCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>[]
        }
        delete: {
          args: Prisma.GuestFollowUpDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        update: {
          args: Prisma.GuestFollowUpUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        deleteMany: {
          args: Prisma.GuestFollowUpDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GuestFollowUpUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GuestFollowUpUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>[]
        }
        upsert: {
          args: Prisma.GuestFollowUpUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GuestFollowUpPayload>
        }
        aggregate: {
          args: Prisma.GuestFollowUpAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGuestFollowUp>
        }
        groupBy: {
          args: Prisma.GuestFollowUpGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestFollowUpGroupByOutputType>[]
        }
        count: {
          args: Prisma.GuestFollowUpCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GuestFollowUpCountAggregateOutputType> | number
        }
      }
    }
    Leave: {
      payload: Prisma.$LeavePayload<ExtArgs>
      fields: Prisma.LeaveFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LeaveFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        findFirst: {
          args: Prisma.LeaveFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        findMany: {
          args: Prisma.LeaveFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>[]
        }
        create: {
          args: Prisma.LeaveCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        createMany: {
          args: Prisma.LeaveCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>[]
        }
        delete: {
          args: Prisma.LeaveDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        update: {
          args: Prisma.LeaveUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        deleteMany: {
          args: Prisma.LeaveDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LeaveUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>[]
        }
        upsert: {
          args: Prisma.LeaveUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LeavePayload>
        }
        aggregate: {
          args: Prisma.LeaveAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLeave>
        }
        groupBy: {
          args: Prisma.LeaveGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveGroupByOutputType>[]
        }
        count: {
          args: Prisma.LeaveCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LeaveCountAggregateOutputType> | number
        }
      }
    }
    PerformanceAppraisal: {
      payload: Prisma.$PerformanceAppraisalPayload<ExtArgs>
      fields: Prisma.PerformanceAppraisalFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PerformanceAppraisalFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PerformanceAppraisalFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        findFirst: {
          args: Prisma.PerformanceAppraisalFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PerformanceAppraisalFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        findMany: {
          args: Prisma.PerformanceAppraisalFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>[]
        }
        create: {
          args: Prisma.PerformanceAppraisalCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        createMany: {
          args: Prisma.PerformanceAppraisalCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PerformanceAppraisalCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>[]
        }
        delete: {
          args: Prisma.PerformanceAppraisalDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        update: {
          args: Prisma.PerformanceAppraisalUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        deleteMany: {
          args: Prisma.PerformanceAppraisalDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PerformanceAppraisalUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PerformanceAppraisalUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>[]
        }
        upsert: {
          args: Prisma.PerformanceAppraisalUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PerformanceAppraisalPayload>
        }
        aggregate: {
          args: Prisma.PerformanceAppraisalAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePerformanceAppraisal>
        }
        groupBy: {
          args: Prisma.PerformanceAppraisalGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerformanceAppraisalGroupByOutputType>[]
        }
        count: {
          args: Prisma.PerformanceAppraisalCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PerformanceAppraisalCountAggregateOutputType> | number
        }
      }
    }
    Church: {
      payload: Prisma.$ChurchPayload<ExtArgs>
      fields: Prisma.ChurchFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChurchFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChurchFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        findFirst: {
          args: Prisma.ChurchFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChurchFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        findMany: {
          args: Prisma.ChurchFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        create: {
          args: Prisma.ChurchCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        createMany: {
          args: Prisma.ChurchCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChurchCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        delete: {
          args: Prisma.ChurchDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        update: {
          args: Prisma.ChurchUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        deleteMany: {
          args: Prisma.ChurchDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChurchUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChurchUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>[]
        }
        upsert: {
          args: Prisma.ChurchUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchPayload>
        }
        aggregate: {
          args: Prisma.ChurchAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChurch>
        }
        groupBy: {
          args: Prisma.ChurchGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChurchCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchCountAggregateOutputType> | number
        }
      }
    }
    ChurchSetting: {
      payload: Prisma.$ChurchSettingPayload<ExtArgs>
      fields: Prisma.ChurchSettingFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChurchSettingFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChurchSettingFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        findFirst: {
          args: Prisma.ChurchSettingFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChurchSettingFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        findMany: {
          args: Prisma.ChurchSettingFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>[]
        }
        create: {
          args: Prisma.ChurchSettingCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        createMany: {
          args: Prisma.ChurchSettingCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChurchSettingCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>[]
        }
        delete: {
          args: Prisma.ChurchSettingDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        update: {
          args: Prisma.ChurchSettingUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        deleteMany: {
          args: Prisma.ChurchSettingDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChurchSettingUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChurchSettingUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>[]
        }
        upsert: {
          args: Prisma.ChurchSettingUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChurchSettingPayload>
        }
        aggregate: {
          args: Prisma.ChurchSettingAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChurchSetting>
        }
        groupBy: {
          args: Prisma.ChurchSettingGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchSettingGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChurchSettingCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChurchSettingCountAggregateOutputType> | number
        }
      }
    }
    CustomField: {
      payload: Prisma.$CustomFieldPayload<ExtArgs>
      fields: Prisma.CustomFieldFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CustomFieldFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CustomFieldFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        findFirst: {
          args: Prisma.CustomFieldFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CustomFieldFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        findMany: {
          args: Prisma.CustomFieldFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
        }
        create: {
          args: Prisma.CustomFieldCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        createMany: {
          args: Prisma.CustomFieldCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CustomFieldCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
        }
        delete: {
          args: Prisma.CustomFieldDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        update: {
          args: Prisma.CustomFieldUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        deleteMany: {
          args: Prisma.CustomFieldDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CustomFieldUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CustomFieldUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>[]
        }
        upsert: {
          args: Prisma.CustomFieldUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CustomFieldPayload>
        }
        aggregate: {
          args: Prisma.CustomFieldAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCustomField>
        }
        groupBy: {
          args: Prisma.CustomFieldGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomFieldGroupByOutputType>[]
        }
        count: {
          args: Prisma.CustomFieldCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CustomFieldCountAggregateOutputType> | number
        }
      }
    }
    Residence: {
      payload: Prisma.$ResidencePayload<ExtArgs>
      fields: Prisma.ResidenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ResidenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ResidenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        findFirst: {
          args: Prisma.ResidenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ResidenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        findMany: {
          args: Prisma.ResidenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>[]
        }
        create: {
          args: Prisma.ResidenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        createMany: {
          args: Prisma.ResidenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ResidenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>[]
        }
        delete: {
          args: Prisma.ResidenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        update: {
          args: Prisma.ResidenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        deleteMany: {
          args: Prisma.ResidenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ResidenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ResidenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>[]
        }
        upsert: {
          args: Prisma.ResidenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ResidencePayload>
        }
        aggregate: {
          args: Prisma.ResidenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateResidence>
        }
        groupBy: {
          args: Prisma.ResidenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResidenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.ResidenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ResidenceCountAggregateOutputType> | number
        }
      }
    }
    PrayerRequest: {
      payload: Prisma.$PrayerRequestPayload<ExtArgs>
      fields: Prisma.PrayerRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrayerRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrayerRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        findFirst: {
          args: Prisma.PrayerRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrayerRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        findMany: {
          args: Prisma.PrayerRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>[]
        }
        create: {
          args: Prisma.PrayerRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        createMany: {
          args: Prisma.PrayerRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrayerRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>[]
        }
        delete: {
          args: Prisma.PrayerRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        update: {
          args: Prisma.PrayerRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        deleteMany: {
          args: Prisma.PrayerRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrayerRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrayerRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>[]
        }
        upsert: {
          args: Prisma.PrayerRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestPayload>
        }
        aggregate: {
          args: Prisma.PrayerRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrayerRequest>
        }
        groupBy: {
          args: Prisma.PrayerRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrayerRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerRequestCountAggregateOutputType> | number
        }
      }
    }
    Prayer: {
      payload: Prisma.$PrayerPayload<ExtArgs>
      fields: Prisma.PrayerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrayerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrayerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        findFirst: {
          args: Prisma.PrayerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrayerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        findMany: {
          args: Prisma.PrayerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>[]
        }
        create: {
          args: Prisma.PrayerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        createMany: {
          args: Prisma.PrayerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrayerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>[]
        }
        delete: {
          args: Prisma.PrayerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        update: {
          args: Prisma.PrayerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        deleteMany: {
          args: Prisma.PrayerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrayerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrayerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>[]
        }
        upsert: {
          args: Prisma.PrayerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerPayload>
        }
        aggregate: {
          args: Prisma.PrayerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrayer>
        }
        groupBy: {
          args: Prisma.PrayerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrayerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerCountAggregateOutputType> | number
        }
      }
    }
    PrayerRequestUpdate: {
      payload: Prisma.$PrayerRequestUpdatePayload<ExtArgs>
      fields: Prisma.PrayerRequestUpdateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PrayerRequestUpdateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PrayerRequestUpdateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        findFirst: {
          args: Prisma.PrayerRequestUpdateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PrayerRequestUpdateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        findMany: {
          args: Prisma.PrayerRequestUpdateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>[]
        }
        create: {
          args: Prisma.PrayerRequestUpdateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        createMany: {
          args: Prisma.PrayerRequestUpdateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PrayerRequestUpdateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>[]
        }
        delete: {
          args: Prisma.PrayerRequestUpdateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        update: {
          args: Prisma.PrayerRequestUpdateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        deleteMany: {
          args: Prisma.PrayerRequestUpdateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PrayerRequestUpdateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PrayerRequestUpdateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>[]
        }
        upsert: {
          args: Prisma.PrayerRequestUpdateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PrayerRequestUpdatePayload>
        }
        aggregate: {
          args: Prisma.PrayerRequestUpdateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePrayerRequestUpdate>
        }
        groupBy: {
          args: Prisma.PrayerRequestUpdateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerRequestUpdateGroupByOutputType>[]
        }
        count: {
          args: Prisma.PrayerRequestUpdateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PrayerRequestUpdateCountAggregateOutputType> | number
        }
      }
    }
    Conversation: {
      payload: Prisma.$ConversationPayload<ExtArgs>
      fields: Prisma.ConversationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findFirst: {
          args: Prisma.ConversationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        findMany: {
          args: Prisma.ConversationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        create: {
          args: Prisma.ConversationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        createMany: {
          args: Prisma.ConversationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        delete: {
          args: Prisma.ConversationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        update: {
          args: Prisma.ConversationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        deleteMany: {
          args: Prisma.ConversationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>[]
        }
        upsert: {
          args: Prisma.ConversationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationPayload>
        }
        aggregate: {
          args: Prisma.ConversationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversation>
        }
        groupBy: {
          args: Prisma.ConversationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationCountAggregateOutputType> | number
        }
      }
    }
    ConversationParticipant: {
      payload: Prisma.$ConversationParticipantPayload<ExtArgs>
      fields: Prisma.ConversationParticipantFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        findFirst: {
          args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        findMany: {
          args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        create: {
          args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        createMany: {
          args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        delete: {
          args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        update: {
          args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        deleteMany: {
          args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
        }
        upsert: {
          args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
        }
        aggregate: {
          args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateConversationParticipant>
        }
        groupBy: {
          args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantGroupByOutputType>[]
        }
        count: {
          args: Prisma.ConversationParticipantCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ConversationParticipantCountAggregateOutputType> | number
        }
      }
    }
    Message: {
      payload: Prisma.$MessagePayload<ExtArgs>
      fields: Prisma.MessageFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findFirst: {
          args: Prisma.MessageFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        findMany: {
          args: Prisma.MessageFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        create: {
          args: Prisma.MessageCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        createMany: {
          args: Prisma.MessageCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        delete: {
          args: Prisma.MessageDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        update: {
          args: Prisma.MessageUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        deleteMany: {
          args: Prisma.MessageDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>[]
        }
        upsert: {
          args: Prisma.MessageUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessagePayload>
        }
        aggregate: {
          args: Prisma.MessageAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessage>
        }
        groupBy: {
          args: Prisma.MessageGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageCountAggregateOutputType> | number
        }
      }
    }
    MessageRead: {
      payload: Prisma.$MessageReadPayload<ExtArgs>
      fields: Prisma.MessageReadFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MessageReadFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MessageReadFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        findFirst: {
          args: Prisma.MessageReadFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MessageReadFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        findMany: {
          args: Prisma.MessageReadFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
        }
        create: {
          args: Prisma.MessageReadCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        createMany: {
          args: Prisma.MessageReadCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MessageReadCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
        }
        delete: {
          args: Prisma.MessageReadDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        update: {
          args: Prisma.MessageReadUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        deleteMany: {
          args: Prisma.MessageReadDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MessageReadUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MessageReadUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
        }
        upsert: {
          args: Prisma.MessageReadUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MessageReadPayload>
        }
        aggregate: {
          args: Prisma.MessageReadAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMessageRead>
        }
        groupBy: {
          args: Prisma.MessageReadGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageReadGroupByOutputType>[]
        }
        count: {
          args: Prisma.MessageReadCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MessageReadCountAggregateOutputType> | number
        }
      }
    }
    Survey: {
      payload: Prisma.$SurveyPayload<ExtArgs>
      fields: Prisma.SurveyFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findFirst: {
          args: Prisma.SurveyFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        findMany: {
          args: Prisma.SurveyFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        create: {
          args: Prisma.SurveyCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        createMany: {
          args: Prisma.SurveyCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        delete: {
          args: Prisma.SurveyDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        update: {
          args: Prisma.SurveyUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        deleteMany: {
          args: Prisma.SurveyDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>[]
        }
        upsert: {
          args: Prisma.SurveyUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyPayload>
        }
        aggregate: {
          args: Prisma.SurveyAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurvey>
        }
        groupBy: {
          args: Prisma.SurveyGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyCountAggregateOutputType> | number
        }
      }
    }
    SurveyQuestion: {
      payload: Prisma.$SurveyQuestionPayload<ExtArgs>
      fields: Prisma.SurveyQuestionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyQuestionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyQuestionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findFirst: {
          args: Prisma.SurveyQuestionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyQuestionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        findMany: {
          args: Prisma.SurveyQuestionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        create: {
          args: Prisma.SurveyQuestionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        createMany: {
          args: Prisma.SurveyQuestionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyQuestionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        delete: {
          args: Prisma.SurveyQuestionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        update: {
          args: Prisma.SurveyQuestionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        deleteMany: {
          args: Prisma.SurveyQuestionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyQuestionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyQuestionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>[]
        }
        upsert: {
          args: Prisma.SurveyQuestionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyQuestionPayload>
        }
        aggregate: {
          args: Prisma.SurveyQuestionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyQuestion>
        }
        groupBy: {
          args: Prisma.SurveyQuestionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyQuestionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyQuestionCountAggregateOutputType> | number
        }
      }
    }
    SurveyResponse: {
      payload: Prisma.$SurveyResponsePayload<ExtArgs>
      fields: Prisma.SurveyResponseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyResponseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyResponseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findFirst: {
          args: Prisma.SurveyResponseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyResponseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        findMany: {
          args: Prisma.SurveyResponseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        create: {
          args: Prisma.SurveyResponseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        createMany: {
          args: Prisma.SurveyResponseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyResponseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        delete: {
          args: Prisma.SurveyResponseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        update: {
          args: Prisma.SurveyResponseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        deleteMany: {
          args: Prisma.SurveyResponseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyResponseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyResponseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>[]
        }
        upsert: {
          args: Prisma.SurveyResponseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponsePayload>
        }
        aggregate: {
          args: Prisma.SurveyResponseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyResponse>
        }
        groupBy: {
          args: Prisma.SurveyResponseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyResponseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseCountAggregateOutputType> | number
        }
      }
    }
    SurveyResponseAnswer: {
      payload: Prisma.$SurveyResponseAnswerPayload<ExtArgs>
      fields: Prisma.SurveyResponseAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SurveyResponseAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SurveyResponseAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        findFirst: {
          args: Prisma.SurveyResponseAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SurveyResponseAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        findMany: {
          args: Prisma.SurveyResponseAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>[]
        }
        create: {
          args: Prisma.SurveyResponseAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        createMany: {
          args: Prisma.SurveyResponseAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SurveyResponseAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>[]
        }
        delete: {
          args: Prisma.SurveyResponseAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        update: {
          args: Prisma.SurveyResponseAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        deleteMany: {
          args: Prisma.SurveyResponseAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SurveyResponseAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SurveyResponseAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>[]
        }
        upsert: {
          args: Prisma.SurveyResponseAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SurveyResponseAnswerPayload>
        }
        aggregate: {
          args: Prisma.SurveyResponseAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSurveyResponseAnswer>
        }
        groupBy: {
          args: Prisma.SurveyResponseAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.SurveyResponseAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SurveyResponseAnswerCountAggregateOutputType> | number
        }
      }
    }
    MemberEngagementScore: {
      payload: Prisma.$MemberEngagementScorePayload<ExtArgs>
      fields: Prisma.MemberEngagementScoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberEngagementScoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberEngagementScoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        findFirst: {
          args: Prisma.MemberEngagementScoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberEngagementScoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        findMany: {
          args: Prisma.MemberEngagementScoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>[]
        }
        create: {
          args: Prisma.MemberEngagementScoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        createMany: {
          args: Prisma.MemberEngagementScoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberEngagementScoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>[]
        }
        delete: {
          args: Prisma.MemberEngagementScoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        update: {
          args: Prisma.MemberEngagementScoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        deleteMany: {
          args: Prisma.MemberEngagementScoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberEngagementScoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberEngagementScoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>[]
        }
        upsert: {
          args: Prisma.MemberEngagementScoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberEngagementScorePayload>
        }
        aggregate: {
          args: Prisma.MemberEngagementScoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberEngagementScore>
        }
        groupBy: {
          args: Prisma.MemberEngagementScoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberEngagementScoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberEngagementScoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberEngagementScoreCountAggregateOutputType> | number
        }
      }
    }
    Workflow: {
      payload: Prisma.$WorkflowPayload<ExtArgs>
      fields: Prisma.WorkflowFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        findFirst: {
          args: Prisma.WorkflowFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        findMany: {
          args: Prisma.WorkflowFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
        }
        create: {
          args: Prisma.WorkflowCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        createMany: {
          args: Prisma.WorkflowCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
        }
        delete: {
          args: Prisma.WorkflowDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        update: {
          args: Prisma.WorkflowUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
        }
        upsert: {
          args: Prisma.WorkflowUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowPayload>
        }
        aggregate: {
          args: Prisma.WorkflowAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflow>
        }
        groupBy: {
          args: Prisma.WorkflowGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowCountAggregateOutputType> | number
        }
      }
    }
    WorkflowAction: {
      payload: Prisma.$WorkflowActionPayload<ExtArgs>
      fields: Prisma.WorkflowActionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowActionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowActionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        findFirst: {
          args: Prisma.WorkflowActionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowActionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        findMany: {
          args: Prisma.WorkflowActionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>[]
        }
        create: {
          args: Prisma.WorkflowActionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        createMany: {
          args: Prisma.WorkflowActionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkflowActionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>[]
        }
        delete: {
          args: Prisma.WorkflowActionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        update: {
          args: Prisma.WorkflowActionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowActionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowActionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkflowActionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>[]
        }
        upsert: {
          args: Prisma.WorkflowActionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionPayload>
        }
        aggregate: {
          args: Prisma.WorkflowActionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflowAction>
        }
        groupBy: {
          args: Prisma.WorkflowActionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowActionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowActionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowActionCountAggregateOutputType> | number
        }
      }
    }
    WorkflowExecution: {
      payload: Prisma.$WorkflowExecutionPayload<ExtArgs>
      fields: Prisma.WorkflowExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        findFirst: {
          args: Prisma.WorkflowExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        findMany: {
          args: Prisma.WorkflowExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
        }
        create: {
          args: Prisma.WorkflowExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        createMany: {
          args: Prisma.WorkflowExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkflowExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
        }
        delete: {
          args: Prisma.WorkflowExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        update: {
          args: Prisma.WorkflowExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkflowExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>[]
        }
        upsert: {
          args: Prisma.WorkflowExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowExecutionPayload>
        }
        aggregate: {
          args: Prisma.WorkflowExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflowExecution>
        }
        groupBy: {
          args: Prisma.WorkflowExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowExecutionCountAggregateOutputType> | number
        }
      }
    }
    WorkflowActionExecution: {
      payload: Prisma.$WorkflowActionExecutionPayload<ExtArgs>
      fields: Prisma.WorkflowActionExecutionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.WorkflowActionExecutionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.WorkflowActionExecutionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        findFirst: {
          args: Prisma.WorkflowActionExecutionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.WorkflowActionExecutionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        findMany: {
          args: Prisma.WorkflowActionExecutionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>[]
        }
        create: {
          args: Prisma.WorkflowActionExecutionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        createMany: {
          args: Prisma.WorkflowActionExecutionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.WorkflowActionExecutionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>[]
        }
        delete: {
          args: Prisma.WorkflowActionExecutionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        update: {
          args: Prisma.WorkflowActionExecutionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        deleteMany: {
          args: Prisma.WorkflowActionExecutionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.WorkflowActionExecutionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.WorkflowActionExecutionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>[]
        }
        upsert: {
          args: Prisma.WorkflowActionExecutionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$WorkflowActionExecutionPayload>
        }
        aggregate: {
          args: Prisma.WorkflowActionExecutionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateWorkflowActionExecution>
        }
        groupBy: {
          args: Prisma.WorkflowActionExecutionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowActionExecutionGroupByOutputType>[]
        }
        count: {
          args: Prisma.WorkflowActionExecutionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.WorkflowActionExecutionCountAggregateOutputType> | number
        }
      }
    }
    Form: {
      payload: Prisma.$FormPayload<ExtArgs>
      fields: Prisma.FormFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        findFirst: {
          args: Prisma.FormFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        findMany: {
          args: Prisma.FormFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        create: {
          args: Prisma.FormCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        createMany: {
          args: Prisma.FormCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        delete: {
          args: Prisma.FormDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        update: {
          args: Prisma.FormUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        deleteMany: {
          args: Prisma.FormDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>[]
        }
        upsert: {
          args: Prisma.FormUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormPayload>
        }
        aggregate: {
          args: Prisma.FormAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateForm>
        }
        groupBy: {
          args: Prisma.FormGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormCountAggregateOutputType> | number
        }
      }
    }
    FormField: {
      payload: Prisma.$FormFieldPayload<ExtArgs>
      fields: Prisma.FormFieldFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormFieldFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormFieldFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        findFirst: {
          args: Prisma.FormFieldFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormFieldFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        findMany: {
          args: Prisma.FormFieldFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
        }
        create: {
          args: Prisma.FormFieldCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        createMany: {
          args: Prisma.FormFieldCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormFieldCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
        }
        delete: {
          args: Prisma.FormFieldDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        update: {
          args: Prisma.FormFieldUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        deleteMany: {
          args: Prisma.FormFieldDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormFieldUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormFieldUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>[]
        }
        upsert: {
          args: Prisma.FormFieldUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormFieldPayload>
        }
        aggregate: {
          args: Prisma.FormFieldAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFormField>
        }
        groupBy: {
          args: Prisma.FormFieldGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormFieldGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormFieldCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormFieldCountAggregateOutputType> | number
        }
      }
    }
    FormSubmission: {
      payload: Prisma.$FormSubmissionPayload<ExtArgs>
      fields: Prisma.FormSubmissionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormSubmissionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormSubmissionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        findFirst: {
          args: Prisma.FormSubmissionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormSubmissionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        findMany: {
          args: Prisma.FormSubmissionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
        }
        create: {
          args: Prisma.FormSubmissionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        createMany: {
          args: Prisma.FormSubmissionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormSubmissionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
        }
        delete: {
          args: Prisma.FormSubmissionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        update: {
          args: Prisma.FormSubmissionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        deleteMany: {
          args: Prisma.FormSubmissionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormSubmissionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormSubmissionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>[]
        }
        upsert: {
          args: Prisma.FormSubmissionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionPayload>
        }
        aggregate: {
          args: Prisma.FormSubmissionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFormSubmission>
        }
        groupBy: {
          args: Prisma.FormSubmissionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormSubmissionGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormSubmissionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormSubmissionCountAggregateOutputType> | number
        }
      }
    }
    FormSubmissionAnswer: {
      payload: Prisma.$FormSubmissionAnswerPayload<ExtArgs>
      fields: Prisma.FormSubmissionAnswerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FormSubmissionAnswerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FormSubmissionAnswerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        findFirst: {
          args: Prisma.FormSubmissionAnswerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FormSubmissionAnswerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        findMany: {
          args: Prisma.FormSubmissionAnswerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>[]
        }
        create: {
          args: Prisma.FormSubmissionAnswerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        createMany: {
          args: Prisma.FormSubmissionAnswerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FormSubmissionAnswerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>[]
        }
        delete: {
          args: Prisma.FormSubmissionAnswerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        update: {
          args: Prisma.FormSubmissionAnswerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        deleteMany: {
          args: Prisma.FormSubmissionAnswerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FormSubmissionAnswerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FormSubmissionAnswerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>[]
        }
        upsert: {
          args: Prisma.FormSubmissionAnswerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FormSubmissionAnswerPayload>
        }
        aggregate: {
          args: Prisma.FormSubmissionAnswerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFormSubmissionAnswer>
        }
        groupBy: {
          args: Prisma.FormSubmissionAnswerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormSubmissionAnswerGroupByOutputType>[]
        }
        count: {
          args: Prisma.FormSubmissionAnswerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FormSubmissionAnswerCountAggregateOutputType> | number
        }
      }
    }
    MemberConnection: {
      payload: Prisma.$MemberConnectionPayload<ExtArgs>
      fields: Prisma.MemberConnectionFieldRefs
      operations: {
        findUnique: {
          args: Prisma.MemberConnectionFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.MemberConnectionFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        findFirst: {
          args: Prisma.MemberConnectionFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.MemberConnectionFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        findMany: {
          args: Prisma.MemberConnectionFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>[]
        }
        create: {
          args: Prisma.MemberConnectionCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        createMany: {
          args: Prisma.MemberConnectionCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.MemberConnectionCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>[]
        }
        delete: {
          args: Prisma.MemberConnectionDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        update: {
          args: Prisma.MemberConnectionUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        deleteMany: {
          args: Prisma.MemberConnectionDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.MemberConnectionUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.MemberConnectionUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>[]
        }
        upsert: {
          args: Prisma.MemberConnectionUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$MemberConnectionPayload>
        }
        aggregate: {
          args: Prisma.MemberConnectionAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateMemberConnection>
        }
        groupBy: {
          args: Prisma.MemberConnectionGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberConnectionGroupByOutputType>[]
        }
        count: {
          args: Prisma.MemberConnectionCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.MemberConnectionCountAggregateOutputType> | number
        }
      }
    }
    CasbinRule: {
      payload: Prisma.$CasbinRulePayload<ExtArgs>
      fields: Prisma.CasbinRuleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CasbinRuleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CasbinRuleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        findFirst: {
          args: Prisma.CasbinRuleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CasbinRuleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        findMany: {
          args: Prisma.CasbinRuleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>[]
        }
        create: {
          args: Prisma.CasbinRuleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        createMany: {
          args: Prisma.CasbinRuleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CasbinRuleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>[]
        }
        delete: {
          args: Prisma.CasbinRuleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        update: {
          args: Prisma.CasbinRuleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        deleteMany: {
          args: Prisma.CasbinRuleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CasbinRuleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CasbinRuleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>[]
        }
        upsert: {
          args: Prisma.CasbinRuleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CasbinRulePayload>
        }
        aggregate: {
          args: Prisma.CasbinRuleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCasbinRule>
        }
        groupBy: {
          args: Prisma.CasbinRuleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CasbinRuleGroupByOutputType>[]
        }
        count: {
          args: Prisma.CasbinRuleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CasbinRuleCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const UserScalarFieldEnum = {
  id: 'id',
  email: 'email',
  phone: 'phone',
  passwordHash: 'passwordHash',
  title: 'title',
  firstName: 'firstName',
  lastName: 'lastName',
  middleName: 'middleName',
  gender: 'gender',
  dateOfBirth: 'dateOfBirth',
  maritalStatus: 'maritalStatus',
  profession: 'profession',
  profileImage: 'profileImage',
  bio: 'bio',
  address: 'address',
  city: 'city',
  state: 'state',
  county: 'county',
  zipCode: 'zipCode',
  country: 'country',
  residence: 'residence',
  emergencyContact: 'emergencyContact',
  emergencyPhone: 'emergencyPhone',
  role: 'role',
  status: 'status',
  canLogin: 'canLogin',
  enableFollowUps: 'enableFollowUps',
  permissions: 'permissions',
  campusId: 'campusId',
  memberSince: 'memberSince',
  baptismDate: 'baptismDate',
  baptismLocation: 'baptismLocation',
  dedicationDate: 'dedicationDate',
  weddingAnniversary: 'weddingAnniversary',
  spouseId: 'spouseId',
  parentId: 'parentId',
  familyPhoto: 'familyPhoto',
  familyHeadId: 'familyHeadId',
  familyName: 'familyName',
  emailVerified: 'emailVerified',
  phoneVerified: 'phoneVerified',
  twoFactorEnabled: 'twoFactorEnabled',
  twoFactorSecret: 'twoFactorSecret',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  lastLoginAt: 'lastLoginAt',
  deletedAt: 'deletedAt'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const SocialLoginScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  provider: 'provider',
  providerId: 'providerId',
  email: 'email',
  createdAt: 'createdAt'
} as const

export type SocialLoginScalarFieldEnum = (typeof SocialLoginScalarFieldEnum)[keyof typeof SocialLoginScalarFieldEnum]


export const UserSessionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  token: 'token',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  expiresAt: 'expiresAt',
  createdAt: 'createdAt',
  lastActivityAt: 'lastActivityAt'
} as const

export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


export const InvitationScalarFieldEnum = {
  id: 'id',
  token: 'token',
  email: 'email',
  phone: 'phone',
  firstName: 'firstName',
  lastName: 'lastName',
  role: 'role',
  campusId: 'campusId',
  invitedById: 'invitedById',
  message: 'message',
  status: 'status',
  acceptedAt: 'acceptedAt',
  expiresAt: 'expiresAt',
  cognitoUserId: 'cognitoUserId',
  userId: 'userId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


export const AuthAccountScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  provider: 'provider',
  providerAccountId: 'providerAccountId',
  refresh_token: 'refresh_token',
  access_token: 'access_token',
  expires_at: 'expires_at',
  token_type: 'token_type',
  scope: 'scope',
  id_token: 'id_token',
  session_state: 'session_state'
} as const

export type AuthAccountScalarFieldEnum = (typeof AuthAccountScalarFieldEnum)[keyof typeof AuthAccountScalarFieldEnum]


export const SessionScalarFieldEnum = {
  id: 'id',
  sessionToken: 'sessionToken',
  userId: 'userId',
  expires: 'expires'
} as const

export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


export const VerificationTokenScalarFieldEnum = {
  identifier: 'identifier',
  token: 'token',
  expires: 'expires'
} as const

export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


export const ActivityLogScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  action: 'action',
  resource: 'resource',
  resourceId: 'resourceId',
  ipAddress: 'ipAddress',
  userAgent: 'userAgent',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


export const CampusScalarFieldEnum = {
  id: 'id',
  name: 'name',
  address: 'address',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  phone: 'phone',
  email: 'email',
  pastorId: 'pastorId',
  churchId: 'churchId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CampusScalarFieldEnum = (typeof CampusScalarFieldEnum)[keyof typeof CampusScalarFieldEnum]


export const SmallGroupScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  type: 'type',
  campusId: 'campusId',
  parentId: 'parentId',
  leaderId: 'leaderId',
  meetingDay: 'meetingDay',
  meetingTime: 'meetingTime',
  meetingLocation: 'meetingLocation',
  latitude: 'latitude',
  longitude: 'longitude',
  useRotation: 'useRotation',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SmallGroupScalarFieldEnum = (typeof SmallGroupScalarFieldEnum)[keyof typeof SmallGroupScalarFieldEnum]


export const GroupMemberScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  userId: 'userId',
  role: 'role',
  isLeader: 'isLeader',
  joinedAt: 'joinedAt',
  leftAt: 'leftAt'
} as const

export type GroupMemberScalarFieldEnum = (typeof GroupMemberScalarFieldEnum)[keyof typeof GroupMemberScalarFieldEnum]


export const GroupMeetingScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  date: 'date',
  location: 'location',
  rotationId: 'rotationId',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupMeetingScalarFieldEnum = (typeof GroupMeetingScalarFieldEnum)[keyof typeof GroupMeetingScalarFieldEnum]


export const GroupMeetingRotationScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  locationType: 'locationType',
  memberId: 'memberId',
  locationName: 'locationName',
  address: 'address',
  month: 'month',
  year: 'year',
  notes: 'notes',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupMeetingRotationScalarFieldEnum = (typeof GroupMeetingRotationScalarFieldEnum)[keyof typeof GroupMeetingRotationScalarFieldEnum]


export const GroupMeetingAttendanceScalarFieldEnum = {
  id: 'id',
  meetingId: 'meetingId',
  userId: 'userId',
  status: 'status',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type GroupMeetingAttendanceScalarFieldEnum = (typeof GroupMeetingAttendanceScalarFieldEnum)[keyof typeof GroupMeetingAttendanceScalarFieldEnum]


export const GroupDiscussionScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  title: 'title',
  content: 'content',
  authorId: 'authorId',
  isPinned: 'isPinned',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupDiscussionScalarFieldEnum = (typeof GroupDiscussionScalarFieldEnum)[keyof typeof GroupDiscussionScalarFieldEnum]


export const GroupDiscussionReplyScalarFieldEnum = {
  id: 'id',
  discussionId: 'discussionId',
  content: 'content',
  authorId: 'authorId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GroupDiscussionReplyScalarFieldEnum = (typeof GroupDiscussionReplyScalarFieldEnum)[keyof typeof GroupDiscussionReplyScalarFieldEnum]


export const DiscipleshipClassScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  duration: 'duration',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DiscipleshipClassScalarFieldEnum = (typeof DiscipleshipClassScalarFieldEnum)[keyof typeof DiscipleshipClassScalarFieldEnum]


export const DiscipleshipEnrollmentScalarFieldEnum = {
  id: 'id',
  classId: 'classId',
  userId: 'userId',
  status: 'status',
  enrolledAt: 'enrolledAt',
  completedAt: 'completedAt'
} as const

export type DiscipleshipEnrollmentScalarFieldEnum = (typeof DiscipleshipEnrollmentScalarFieldEnum)[keyof typeof DiscipleshipEnrollmentScalarFieldEnum]


export const MentorshipScalarFieldEnum = {
  id: 'id',
  mentorId: 'mentorId',
  menteeId: 'menteeId',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MentorshipScalarFieldEnum = (typeof MentorshipScalarFieldEnum)[keyof typeof MentorshipScalarFieldEnum]


export const MentorshipMeetingScalarFieldEnum = {
  id: 'id',
  mentorshipId: 'mentorshipId',
  date: 'date',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type MentorshipMeetingScalarFieldEnum = (typeof MentorshipMeetingScalarFieldEnum)[keyof typeof MentorshipMeetingScalarFieldEnum]


export const AnnouncementScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  authorId: 'authorId',
  priority: 'priority',
  targetAudience: 'targetAudience',
  campusId: 'campusId',
  publishAt: 'publishAt',
  expiresAt: 'expiresAt',
  isPublished: 'isPublished',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AnnouncementScalarFieldEnum = (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum]


export const AnnouncementReadScalarFieldEnum = {
  id: 'id',
  announcementId: 'announcementId',
  userId: 'userId',
  readAt: 'readAt'
} as const

export type AnnouncementReadScalarFieldEnum = (typeof AnnouncementReadScalarFieldEnum)[keyof typeof AnnouncementReadScalarFieldEnum]


export const NotificationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  type: 'type',
  title: 'title',
  content: 'content',
  link: 'link',
  isRead: 'isRead',
  readAt: 'readAt',
  announcementId: 'announcementId',
  relatedUserId: 'relatedUserId',
  metadata: 'metadata',
  createdAt: 'createdAt'
} as const

export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


export const MessageTemplateScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  type: 'type',
  subject: 'subject',
  content: 'content',
  variables: 'variables',
  trigger: 'trigger',
  isActive: 'isActive',
  isDefault: 'isDefault',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MessageTemplateScalarFieldEnum = (typeof MessageTemplateScalarFieldEnum)[keyof typeof MessageTemplateScalarFieldEnum]


export const ServicePlanScalarFieldEnum = {
  id: 'id',
  title: 'title',
  date: 'date',
  campusId: 'campusId',
  notes: 'notes',
  isPublished: 'isPublished',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServicePlanScalarFieldEnum = (typeof ServicePlanScalarFieldEnum)[keyof typeof ServicePlanScalarFieldEnum]


export const ServicePlanItemScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  type: 'type',
  title: 'title',
  description: 'description',
  order: 'order',
  duration: 'duration',
  lyrics: 'lyrics',
  chords: 'chords',
  notes: 'notes',
  mediaId: 'mediaId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServicePlanItemScalarFieldEnum = (typeof ServicePlanItemScalarFieldEnum)[keyof typeof ServicePlanItemScalarFieldEnum]


export const ServiceAssignmentScalarFieldEnum = {
  id: 'id',
  planId: 'planId',
  userId: 'userId',
  role: 'role',
  notes: 'notes',
  confirmed: 'confirmed',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ServiceAssignmentScalarFieldEnum = (typeof ServiceAssignmentScalarFieldEnum)[keyof typeof ServiceAssignmentScalarFieldEnum]


export const MediaScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  type: 'type',
  category: 'category',
  series: 'series',
  speaker: 'speaker',
  url: 'url',
  thumbnailUrl: 'thumbnailUrl',
  duration: 'duration',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  externalId: 'externalId',
  externalUrl: 'externalUrl',
  tags: 'tags',
  isPublic: 'isPublic',
  viewCount: 'viewCount',
  downloadCount: 'downloadCount',
  uploadedById: 'uploadedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


export const LivestreamScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  servicePlanId: 'servicePlanId',
  platform: 'platform',
  streamUrl: 'streamUrl',
  embedUrl: 'embedUrl',
  status: 'status',
  scheduledAt: 'scheduledAt',
  startedAt: 'startedAt',
  endedAt: 'endedAt',
  viewCount: 'viewCount',
  peakViewers: 'peakViewers',
  isMembersOnly: 'isMembersOnly',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LivestreamScalarFieldEnum = (typeof LivestreamScalarFieldEnum)[keyof typeof LivestreamScalarFieldEnum]


export const LivestreamChatScalarFieldEnum = {
  id: 'id',
  livestreamId: 'livestreamId',
  userId: 'userId',
  userName: 'userName',
  message: 'message',
  isPrayerRequest: 'isPrayerRequest',
  isModerated: 'isModerated',
  createdAt: 'createdAt'
} as const

export type LivestreamChatScalarFieldEnum = (typeof LivestreamChatScalarFieldEnum)[keyof typeof LivestreamChatScalarFieldEnum]


export const LivestreamAnalyticsScalarFieldEnum = {
  id: 'id',
  livestreamId: 'livestreamId',
  timestamp: 'timestamp',
  viewCount: 'viewCount',
  watchTime: 'watchTime',
  engagement: 'engagement',
  metadata: 'metadata'
} as const

export type LivestreamAnalyticsScalarFieldEnum = (typeof LivestreamAnalyticsScalarFieldEnum)[keyof typeof LivestreamAnalyticsScalarFieldEnum]


export const AttendanceScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  date: 'date',
  type: 'type',
  referenceId: 'referenceId',
  status: 'status',
  checkInMethod: 'checkInMethod',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


export const DonationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  amount: 'amount',
  category: 'category',
  paymentMethod: 'paymentMethod',
  transactionId: 'transactionId',
  reference: 'reference',
  notes: 'notes',
  isRecurring: 'isRecurring',
  recurringId: 'recurringId',
  receiptSent: 'receiptSent',
  receiptSentAt: 'receiptSentAt',
  status: 'status',
  metadata: 'metadata',
  qrCodeId: 'qrCodeId',
  mpesaRequestId: 'mpesaRequestId',
  mpesaCheckoutId: 'mpesaCheckoutId',
  paypalTransactionId: 'paypalTransactionId',
  paypalOrderId: 'paypalOrderId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  recurringDonationId: 'recurringDonationId'
} as const

export type DonationScalarFieldEnum = (typeof DonationScalarFieldEnum)[keyof typeof DonationScalarFieldEnum]


export const GivingQRCodeScalarFieldEnum = {
  id: 'id',
  donationId: 'donationId',
  amount: 'amount',
  category: 'category',
  qrCodeData: 'qrCodeData',
  qrCodeUrl: 'qrCodeUrl',
  expiresAt: 'expiresAt',
  isUsed: 'isUsed',
  usedAt: 'usedAt',
  createdAt: 'createdAt'
} as const

export type GivingQRCodeScalarFieldEnum = (typeof GivingQRCodeScalarFieldEnum)[keyof typeof GivingQRCodeScalarFieldEnum]


export const RecurringDonationScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  amount: 'amount',
  category: 'category',
  frequency: 'frequency',
  dayOfMonth: 'dayOfMonth',
  dayOfWeek: 'dayOfWeek',
  paymentMethod: 'paymentMethod',
  nextDate: 'nextDate',
  isActive: 'isActive',
  endDate: 'endDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type RecurringDonationScalarFieldEnum = (typeof RecurringDonationScalarFieldEnum)[keyof typeof RecurringDonationScalarFieldEnum]


export const ExpenseScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  amount: 'amount',
  category: 'category',
  vendor: 'vendor',
  submittedById: 'submittedById',
  approvedById: 'approvedById',
  status: 'status',
  receiptUrl: 'receiptUrl',
  notes: 'notes',
  expenseDate: 'expenseDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


export const BudgetScalarFieldEnum = {
  id: 'id',
  name: 'name',
  category: 'category',
  amount: 'amount',
  period: 'period',
  startDate: 'startDate',
  endDate: 'endDate',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type BudgetScalarFieldEnum = (typeof BudgetScalarFieldEnum)[keyof typeof BudgetScalarFieldEnum]


export const AccountScalarFieldEnum = {
  id: 'id',
  name: 'name',
  type: 'type',
  code: 'code',
  balance: 'balance',
  churchId: 'churchId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


export const TransactionScalarFieldEnum = {
  id: 'id',
  accountId: 'accountId',
  type: 'type',
  amount: 'amount',
  description: 'description',
  reference: 'reference',
  referenceType: 'referenceType',
  date: 'date',
  reconciled: 'reconciled',
  reconciledAt: 'reconciledAt',
  createdAt: 'createdAt'
} as const

export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


export const EventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  type: 'type',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  location: 'location',
  address: 'address',
  campusId: 'campusId',
  capacity: 'capacity',
  isPublic: 'isPublic',
  requiresRegistration: 'requiresRegistration',
  isPaid: 'isPaid',
  price: 'price',
  imageUrl: 'imageUrl',
  posterUrl: 'posterUrl',
  organizerId: 'organizerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


export const EventRegistrationScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  status: 'status',
  paymentStatus: 'paymentStatus',
  paymentAmount: 'paymentAmount',
  notes: 'notes',
  registeredAt: 'registeredAt',
  updatedAt: 'updatedAt'
} as const

export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


export const EventCheckInScalarFieldEnum = {
  id: 'id',
  eventId: 'eventId',
  userId: 'userId',
  checkedInAt: 'checkedInAt',
  method: 'method'
} as const

export type EventCheckInScalarFieldEnum = (typeof EventCheckInScalarFieldEnum)[keyof typeof EventCheckInScalarFieldEnum]


export const CalendarEventScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  startDate: 'startDate',
  endDate: 'endDate',
  allDay: 'allDay',
  location: 'location',
  type: 'type',
  color: 'color',
  isRecurring: 'isRecurring',
  recurrenceRule: 'recurrenceRule',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CalendarEventScalarFieldEnum = (typeof CalendarEventScalarFieldEnum)[keyof typeof CalendarEventScalarFieldEnum]


export const FacilityScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  capacity: 'capacity',
  amenities: 'amenities',
  campusId: 'campusId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityScalarFieldEnum = (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum]


export const FacilityBookingScalarFieldEnum = {
  id: 'id',
  facilityId: 'facilityId',
  userId: 'userId',
  startDate: 'startDate',
  endDate: 'endDate',
  purpose: 'purpose',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FacilityBookingScalarFieldEnum = (typeof FacilityBookingScalarFieldEnum)[keyof typeof FacilityBookingScalarFieldEnum]


export const VolunteerRoleScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  department: 'department',
  requirements: 'requirements',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerRoleScalarFieldEnum = (typeof VolunteerRoleScalarFieldEnum)[keyof typeof VolunteerRoleScalarFieldEnum]


export const VolunteerAssignmentScalarFieldEnum = {
  id: 'id',
  roleId: 'roleId',
  userId: 'userId',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerAssignmentScalarFieldEnum = (typeof VolunteerAssignmentScalarFieldEnum)[keyof typeof VolunteerAssignmentScalarFieldEnum]


export const VolunteerShiftScalarFieldEnum = {
  id: 'id',
  assignmentId: 'assignmentId',
  date: 'date',
  startTime: 'startTime',
  endTime: 'endTime',
  status: 'status',
  notes: 'notes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type VolunteerShiftScalarFieldEnum = (typeof VolunteerShiftScalarFieldEnum)[keyof typeof VolunteerShiftScalarFieldEnum]


export const ChildrenClassScalarFieldEnum = {
  id: 'id',
  name: 'name',
  ageMin: 'ageMin',
  ageMax: 'ageMax',
  capacity: 'capacity',
  leaderId: 'leaderId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChildrenClassScalarFieldEnum = (typeof ChildrenClassScalarFieldEnum)[keyof typeof ChildrenClassScalarFieldEnum]


export const ChildrenMinistryMemberScalarFieldEnum = {
  id: 'id',
  classId: 'classId',
  userId: 'userId',
  parentId: 'parentId',
  allergies: 'allergies',
  specialNeeds: 'specialNeeds',
  checkInCode: 'checkInCode',
  enrolledAt: 'enrolledAt',
  leftAt: 'leftAt'
} as const

export type ChildrenMinistryMemberScalarFieldEnum = (typeof ChildrenMinistryMemberScalarFieldEnum)[keyof typeof ChildrenMinistryMemberScalarFieldEnum]


export const ChildrenAttendanceScalarFieldEnum = {
  id: 'id',
  memberId: 'memberId',
  date: 'date',
  checkedInAt: 'checkedInAt',
  checkedOutAt: 'checkedOutAt',
  checkedInBy: 'checkedInBy',
  checkedOutBy: 'checkedOutBy',
  notes: 'notes'
} as const

export type ChildrenAttendanceScalarFieldEnum = (typeof ChildrenAttendanceScalarFieldEnum)[keyof typeof ChildrenAttendanceScalarFieldEnum]


export const ChildrenLessonScalarFieldEnum = {
  id: 'id',
  classId: 'classId',
  title: 'title',
  content: 'content',
  scripture: 'scripture',
  materials: 'materials',
  date: 'date',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChildrenLessonScalarFieldEnum = (typeof ChildrenLessonScalarFieldEnum)[keyof typeof ChildrenLessonScalarFieldEnum]


export const YouthGroupScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  ageMin: 'ageMin',
  ageMax: 'ageMax',
  leaderId: 'leaderId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type YouthGroupScalarFieldEnum = (typeof YouthGroupScalarFieldEnum)[keyof typeof YouthGroupScalarFieldEnum]


export const YouthGroupMemberScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  userId: 'userId',
  joinedAt: 'joinedAt',
  leftAt: 'leftAt'
} as const

export type YouthGroupMemberScalarFieldEnum = (typeof YouthGroupMemberScalarFieldEnum)[keyof typeof YouthGroupMemberScalarFieldEnum]


export const YouthEventScalarFieldEnum = {
  id: 'id',
  groupId: 'groupId',
  title: 'title',
  description: 'description',
  date: 'date',
  location: 'location',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type YouthEventScalarFieldEnum = (typeof YouthEventScalarFieldEnum)[keyof typeof YouthEventScalarFieldEnum]


export const OutreachScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  type: 'type',
  startDate: 'startDate',
  endDate: 'endDate',
  location: 'location',
  budget: 'budget',
  status: 'status',
  organizerId: 'organizerId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OutreachScalarFieldEnum = (typeof OutreachScalarFieldEnum)[keyof typeof OutreachScalarFieldEnum]


export const OutreachParticipantScalarFieldEnum = {
  id: 'id',
  outreachId: 'outreachId',
  userId: 'userId',
  role: 'role',
  status: 'status',
  createdAt: 'createdAt'
} as const

export type OutreachParticipantScalarFieldEnum = (typeof OutreachParticipantScalarFieldEnum)[keyof typeof OutreachParticipantScalarFieldEnum]


export const OutreachTestimonyScalarFieldEnum = {
  id: 'id',
  outreachId: 'outreachId',
  authorId: 'authorId',
  title: 'title',
  content: 'content',
  isPublic: 'isPublic',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type OutreachTestimonyScalarFieldEnum = (typeof OutreachTestimonyScalarFieldEnum)[keyof typeof OutreachTestimonyScalarFieldEnum]


export const CommunityProjectScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  goal: 'goal',
  currentAmount: 'currentAmount',
  status: 'status',
  startDate: 'startDate',
  endDate: 'endDate',
  isPublic: 'isPublic',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CommunityProjectScalarFieldEnum = (typeof CommunityProjectScalarFieldEnum)[keyof typeof CommunityProjectScalarFieldEnum]


export const ProjectDonationScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  userId: 'userId',
  amount: 'amount',
  anonymous: 'anonymous',
  createdAt: 'createdAt'
} as const

export type ProjectDonationScalarFieldEnum = (typeof ProjectDonationScalarFieldEnum)[keyof typeof ProjectDonationScalarFieldEnum]


export const ProjectUpdateScalarFieldEnum = {
  id: 'id',
  projectId: 'projectId',
  title: 'title',
  content: 'content',
  imageUrl: 'imageUrl',
  authorId: 'authorId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ProjectUpdateScalarFieldEnum = (typeof ProjectUpdateScalarFieldEnum)[keyof typeof ProjectUpdateScalarFieldEnum]


export const DocumentScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  type: 'type',
  category: 'category',
  fileUrl: 'fileUrl',
  fileSize: 'fileSize',
  mimeType: 'mimeType',
  version: 'version',
  previousVersionId: 'previousVersionId',
  isPublic: 'isPublic',
  accessLevel: 'accessLevel',
  uploadedById: 'uploadedById',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


export const AssetScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  category: 'category',
  serialNumber: 'serialNumber',
  purchaseDate: 'purchaseDate',
  purchasePrice: 'purchasePrice',
  currentValue: 'currentValue',
  location: 'location',
  campusId: 'campusId',
  status: 'status',
  warrantyExpiry: 'warrantyExpiry',
  assignedToId: 'assignedToId',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type AssetScalarFieldEnum = (typeof AssetScalarFieldEnum)[keyof typeof AssetScalarFieldEnum]


export const AssetMaintenanceScalarFieldEnum = {
  id: 'id',
  assetId: 'assetId',
  type: 'type',
  description: 'description',
  cost: 'cost',
  performedBy: 'performedBy',
  performedAt: 'performedAt',
  nextServiceDate: 'nextServiceDate',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type AssetMaintenanceScalarFieldEnum = (typeof AssetMaintenanceScalarFieldEnum)[keyof typeof AssetMaintenanceScalarFieldEnum]


export const DepartmentScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  leaderId: 'leaderId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


export const InventoryItemScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  category: 'category',
  sku: 'sku',
  quantity: 'quantity',
  unit: 'unit',
  minQuantity: 'minQuantity',
  maxQuantity: 'maxQuantity',
  unitCost: 'unitCost',
  location: 'location',
  departmentId: 'departmentId',
  supplier: 'supplier',
  lastRestocked: 'lastRestocked',
  notes: 'notes',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


export const InventoryTransactionScalarFieldEnum = {
  id: 'id',
  itemId: 'itemId',
  type: 'type',
  quantity: 'quantity',
  reason: 'reason',
  performedById: 'performedById',
  notes: 'notes',
  createdAt: 'createdAt'
} as const

export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


export const StaffScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  employeeId: 'employeeId',
  departmentId: 'departmentId',
  position: 'position',
  hireDate: 'hireDate',
  salary: 'salary',
  employmentType: 'employmentType',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type StaffScalarFieldEnum = (typeof StaffScalarFieldEnum)[keyof typeof StaffScalarFieldEnum]


export const PayrollScalarFieldEnum = {
  id: 'id',
  payPeriod: 'payPeriod',
  startDate: 'startDate',
  endDate: 'endDate',
  status: 'status',
  totalAmount: 'totalAmount',
  processedById: 'processedById',
  processedAt: 'processedAt',
  notes: 'notes',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


export const PayslipScalarFieldEnum = {
  id: 'id',
  payrollId: 'payrollId',
  staffId: 'staffId',
  baseSalary: 'baseSalary',
  allowances: 'allowances',
  bonuses: 'bonuses',
  deductions: 'deductions',
  netPay: 'netPay',
  payDate: 'payDate',
  status: 'status',
  generatedById: 'generatedById',
  generatedAt: 'generatedAt',
  sentAt: 'sentAt',
  payslipUrl: 'payslipUrl',
  notes: 'notes',
  breakdown: 'breakdown',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PayslipScalarFieldEnum = (typeof PayslipScalarFieldEnum)[keyof typeof PayslipScalarFieldEnum]


export const CheckScalarFieldEnum = {
  id: 'id',
  checkNumber: 'checkNumber',
  amount: 'amount',
  donorId: 'donorId',
  donorName: 'donorName',
  bankName: 'bankName',
  accountNumber: 'accountNumber',
  checkDate: 'checkDate',
  receivedDate: 'receivedDate',
  receivedById: 'receivedById',
  status: 'status',
  depositedDate: 'depositedDate',
  depositedById: 'depositedById',
  clearedDate: 'clearedDate',
  donationId: 'donationId',
  notes: 'notes',
  imageUrl: 'imageUrl',
  churchId: 'churchId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CheckScalarFieldEnum = (typeof CheckScalarFieldEnum)[keyof typeof CheckScalarFieldEnum]


export const GuestVisitScalarFieldEnum = {
  id: 'id',
  guestId: 'guestId',
  visitDate: 'visitDate',
  serviceType: 'serviceType',
  eventId: 'eventId',
  notes: 'notes',
  recordedById: 'recordedById',
  createdAt: 'createdAt'
} as const

export type GuestVisitScalarFieldEnum = (typeof GuestVisitScalarFieldEnum)[keyof typeof GuestVisitScalarFieldEnum]


export const GuestFollowUpScalarFieldEnum = {
  id: 'id',
  guestId: 'guestId',
  type: 'type',
  method: 'method',
  subject: 'subject',
  content: 'content',
  scheduledAt: 'scheduledAt',
  completedAt: 'completedAt',
  status: 'status',
  assignedToId: 'assignedToId',
  createdById: 'createdById',
  notes: 'notes',
  metadata: 'metadata',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type GuestFollowUpScalarFieldEnum = (typeof GuestFollowUpScalarFieldEnum)[keyof typeof GuestFollowUpScalarFieldEnum]


export const LeaveScalarFieldEnum = {
  id: 'id',
  staffId: 'staffId',
  type: 'type',
  startDate: 'startDate',
  endDate: 'endDate',
  days: 'days',
  reason: 'reason',
  status: 'status',
  approvedById: 'approvedById',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


export const PerformanceAppraisalScalarFieldEnum = {
  id: 'id',
  staffId: 'staffId',
  period: 'period',
  rating: 'rating',
  comments: 'comments',
  goals: 'goals',
  reviewedById: 'reviewedById',
  reviewDate: 'reviewDate',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PerformanceAppraisalScalarFieldEnum = (typeof PerformanceAppraisalScalarFieldEnum)[keyof typeof PerformanceAppraisalScalarFieldEnum]


export const ChurchScalarFieldEnum = {
  id: 'id',
  name: 'name',
  denomination: 'denomination',
  logo: 'logo',
  website: 'website',
  email: 'email',
  phone: 'phone',
  address: 'address',
  city: 'city',
  state: 'state',
  zipCode: 'zipCode',
  country: 'country',
  timezone: 'timezone',
  language: 'language',
  currency: 'currency',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChurchScalarFieldEnum = (typeof ChurchScalarFieldEnum)[keyof typeof ChurchScalarFieldEnum]


export const ChurchSettingScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  key: 'key',
  value: 'value',
  type: 'type',
  description: 'description',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ChurchSettingScalarFieldEnum = (typeof ChurchSettingScalarFieldEnum)[keyof typeof ChurchSettingScalarFieldEnum]


export const CustomFieldScalarFieldEnum = {
  id: 'id',
  churchId: 'churchId',
  name: 'name',
  label: 'label',
  type: 'type',
  options: 'options',
  entity: 'entity',
  isRequired: 'isRequired',
  isActive: 'isActive',
  order: 'order',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type CustomFieldScalarFieldEnum = (typeof CustomFieldScalarFieldEnum)[keyof typeof CustomFieldScalarFieldEnum]


export const ResidenceScalarFieldEnum = {
  id: 'id',
  name: 'name',
  churchId: 'churchId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ResidenceScalarFieldEnum = (typeof ResidenceScalarFieldEnum)[keyof typeof ResidenceScalarFieldEnum]


export const PrayerRequestScalarFieldEnum = {
  id: 'id',
  title: 'title',
  content: 'content',
  category: 'category',
  status: 'status',
  privacy: 'privacy',
  isAnonymous: 'isAnonymous',
  authorId: 'authorId',
  answeredAt: 'answeredAt',
  answerNotes: 'answerNotes',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type PrayerRequestScalarFieldEnum = (typeof PrayerRequestScalarFieldEnum)[keyof typeof PrayerRequestScalarFieldEnum]


export const PrayerScalarFieldEnum = {
  id: 'id',
  prayerRequestId: 'prayerRequestId',
  userId: 'userId',
  notes: 'notes',
  isAnonymous: 'isAnonymous',
  createdAt: 'createdAt'
} as const

export type PrayerScalarFieldEnum = (typeof PrayerScalarFieldEnum)[keyof typeof PrayerScalarFieldEnum]


export const PrayerRequestUpdateScalarFieldEnum = {
  id: 'id',
  prayerRequestId: 'prayerRequestId',
  content: 'content',
  authorId: 'authorId',
  createdAt: 'createdAt'
} as const

export type PrayerRequestUpdateScalarFieldEnum = (typeof PrayerRequestUpdateScalarFieldEnum)[keyof typeof PrayerRequestUpdateScalarFieldEnum]


export const ConversationScalarFieldEnum = {
  id: 'id',
  type: 'type',
  name: 'name',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


export const ConversationParticipantScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  userId: 'userId',
  lastReadAt: 'lastReadAt',
  isMuted: 'isMuted',
  joinedAt: 'joinedAt'
} as const

export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


export const MessageScalarFieldEnum = {
  id: 'id',
  conversationId: 'conversationId',
  senderId: 'senderId',
  content: 'content',
  attachments: 'attachments',
  isEdited: 'isEdited',
  editedAt: 'editedAt',
  isDeleted: 'isDeleted',
  deletedAt: 'deletedAt',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


export const MessageReadScalarFieldEnum = {
  id: 'id',
  messageId: 'messageId',
  userId: 'userId',
  readAt: 'readAt'
} as const

export type MessageReadScalarFieldEnum = (typeof MessageReadScalarFieldEnum)[keyof typeof MessageReadScalarFieldEnum]


export const SurveyScalarFieldEnum = {
  id: 'id',
  title: 'title',
  description: 'description',
  status: 'status',
  isAnonymous: 'isAnonymous',
  allowMultiple: 'allowMultiple',
  startDate: 'startDate',
  endDate: 'endDate',
  targetAudience: 'targetAudience',
  authorId: 'authorId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type SurveyScalarFieldEnum = (typeof SurveyScalarFieldEnum)[keyof typeof SurveyScalarFieldEnum]


export const SurveyQuestionScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  question: 'question',
  type: 'type',
  options: 'options',
  isRequired: 'isRequired',
  order: 'order',
  description: 'description',
  createdAt: 'createdAt'
} as const

export type SurveyQuestionScalarFieldEnum = (typeof SurveyQuestionScalarFieldEnum)[keyof typeof SurveyQuestionScalarFieldEnum]


export const SurveyResponseScalarFieldEnum = {
  id: 'id',
  surveyId: 'surveyId',
  userId: 'userId',
  isAnonymous: 'isAnonymous',
  submittedAt: 'submittedAt'
} as const

export type SurveyResponseScalarFieldEnum = (typeof SurveyResponseScalarFieldEnum)[keyof typeof SurveyResponseScalarFieldEnum]


export const SurveyResponseAnswerScalarFieldEnum = {
  id: 'id',
  responseId: 'responseId',
  questionId: 'questionId',
  answer: 'answer',
  createdAt: 'createdAt'
} as const

export type SurveyResponseAnswerScalarFieldEnum = (typeof SurveyResponseAnswerScalarFieldEnum)[keyof typeof SurveyResponseAnswerScalarFieldEnum]


export const MemberEngagementScoreScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  overallScore: 'overallScore',
  attendanceScore: 'attendanceScore',
  givingScore: 'givingScore',
  groupScore: 'groupScore',
  eventScore: 'eventScore',
  communicationScore: 'communicationScore',
  volunteerScore: 'volunteerScore',
  calculatedAt: 'calculatedAt',
  period: 'period',
  periodStart: 'periodStart',
  periodEnd: 'periodEnd',
  metadata: 'metadata'
} as const

export type MemberEngagementScoreScalarFieldEnum = (typeof MemberEngagementScoreScalarFieldEnum)[keyof typeof MemberEngagementScoreScalarFieldEnum]


export const WorkflowScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  status: 'status',
  triggerType: 'triggerType',
  triggerConfig: 'triggerConfig',
  authorId: 'authorId',
  isActive: 'isActive',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


export const WorkflowActionScalarFieldEnum = {
  id: 'id',
  workflowId: 'workflowId',
  type: 'type',
  order: 'order',
  config: 'config',
  conditions: 'conditions',
  delay: 'delay',
  createdAt: 'createdAt'
} as const

export type WorkflowActionScalarFieldEnum = (typeof WorkflowActionScalarFieldEnum)[keyof typeof WorkflowActionScalarFieldEnum]


export const WorkflowExecutionScalarFieldEnum = {
  id: 'id',
  workflowId: 'workflowId',
  triggerData: 'triggerData',
  status: 'status',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  error: 'error',
  metadata: 'metadata'
} as const

export type WorkflowExecutionScalarFieldEnum = (typeof WorkflowExecutionScalarFieldEnum)[keyof typeof WorkflowExecutionScalarFieldEnum]


export const WorkflowActionExecutionScalarFieldEnum = {
  id: 'id',
  executionId: 'executionId',
  actionId: 'actionId',
  status: 'status',
  result: 'result',
  error: 'error',
  executedAt: 'executedAt',
  createdAt: 'createdAt'
} as const

export type WorkflowActionExecutionScalarFieldEnum = (typeof WorkflowActionExecutionScalarFieldEnum)[keyof typeof WorkflowActionExecutionScalarFieldEnum]


export const FormScalarFieldEnum = {
  id: 'id',
  name: 'name',
  description: 'description',
  status: 'status',
  isPublic: 'isPublic',
  allowMultiple: 'allowMultiple',
  requireAuth: 'requireAuth',
  startDate: 'startDate',
  endDate: 'endDate',
  authorId: 'authorId',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type FormScalarFieldEnum = (typeof FormScalarFieldEnum)[keyof typeof FormScalarFieldEnum]


export const FormFieldScalarFieldEnum = {
  id: 'id',
  formId: 'formId',
  label: 'label',
  type: 'type',
  placeholder: 'placeholder',
  helpText: 'helpText',
  options: 'options',
  isRequired: 'isRequired',
  order: 'order',
  validation: 'validation',
  conditional: 'conditional',
  createdAt: 'createdAt'
} as const

export type FormFieldScalarFieldEnum = (typeof FormFieldScalarFieldEnum)[keyof typeof FormFieldScalarFieldEnum]


export const FormSubmissionScalarFieldEnum = {
  id: 'id',
  formId: 'formId',
  userId: 'userId',
  isAnonymous: 'isAnonymous',
  submittedAt: 'submittedAt'
} as const

export type FormSubmissionScalarFieldEnum = (typeof FormSubmissionScalarFieldEnum)[keyof typeof FormSubmissionScalarFieldEnum]


export const FormSubmissionAnswerScalarFieldEnum = {
  id: 'id',
  submissionId: 'submissionId',
  fieldId: 'fieldId',
  answer: 'answer',
  createdAt: 'createdAt'
} as const

export type FormSubmissionAnswerScalarFieldEnum = (typeof FormSubmissionAnswerScalarFieldEnum)[keyof typeof FormSubmissionAnswerScalarFieldEnum]


export const MemberConnectionScalarFieldEnum = {
  id: 'id',
  userId: 'userId',
  connectedUserId: 'connectedUserId',
  status: 'status',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt'
} as const

export type MemberConnectionScalarFieldEnum = (typeof MemberConnectionScalarFieldEnum)[keyof typeof MemberConnectionScalarFieldEnum]


export const CasbinRuleScalarFieldEnum = {
  id: 'id',
  ptype: 'ptype',
  v0: 'v0',
  v1: 'v1',
  v2: 'v2',
  v3: 'v3',
  v4: 'v4',
  v5: 'v5'
} as const

export type CasbinRuleScalarFieldEnum = (typeof CasbinRuleScalarFieldEnum)[keyof typeof CasbinRuleScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const NullableJsonNullValueInput = {
  DbNull: DbNull,
  JsonNull: JsonNull
} as const

export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


export const JsonNullValueInput = {
  JsonNull: JsonNull
} as const

export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const JsonNullValueFilter = {
  DbNull: DbNull,
  JsonNull: JsonNull,
  AnyNull: AnyNull
} as const

export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


/**
 * Reference to a field of type 'Gender'
 */
export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


/**
 * Reference to a field of type 'Gender[]'
 */
export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'MaritalStatus'
 */
export type EnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus'>
    


/**
 * Reference to a field of type 'MaritalStatus[]'
 */
export type ListEnumMaritalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaritalStatus[]'>
    


/**
 * Reference to a field of type 'UserRole'
 */
export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


/**
 * Reference to a field of type 'UserRole[]'
 */
export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


/**
 * Reference to a field of type 'UserStatus'
 */
export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


/**
 * Reference to a field of type 'UserStatus[]'
 */
export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Json'
 */
export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


/**
 * Reference to a field of type 'QueryMode'
 */
export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


/**
 * Reference to a field of type 'InvitationStatus'
 */
export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


/**
 * Reference to a field of type 'InvitationStatus[]'
 */
export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'AttendanceStatus'
 */
export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


/**
 * Reference to a field of type 'AttendanceStatus[]'
 */
export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


/**
 * Reference to a field of type 'NotificationType'
 */
export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


/**
 * Reference to a field of type 'NotificationType[]'
 */
export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


/**
 * Reference to a field of type 'MessageTemplateCategory'
 */
export type EnumMessageTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageTemplateCategory'>
    


/**
 * Reference to a field of type 'MessageTemplateCategory[]'
 */
export type ListEnumMessageTemplateCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageTemplateCategory[]'>
    


/**
 * Reference to a field of type 'MediaType'
 */
export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


/**
 * Reference to a field of type 'MediaType[]'
 */
export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


/**
 * Reference to a field of type 'BigInt'
 */
export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


/**
 * Reference to a field of type 'BigInt[]'
 */
export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


/**
 * Reference to a field of type 'LivestreamStatus'
 */
export type EnumLivestreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LivestreamStatus'>
    


/**
 * Reference to a field of type 'LivestreamStatus[]'
 */
export type ListEnumLivestreamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LivestreamStatus[]'>
    


/**
 * Reference to a field of type 'Decimal'
 */
export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


/**
 * Reference to a field of type 'Decimal[]'
 */
export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


/**
 * Reference to a field of type 'GivingCategory'
 */
export type EnumGivingCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GivingCategory'>
    


/**
 * Reference to a field of type 'GivingCategory[]'
 */
export type ListEnumGivingCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GivingCategory[]'>
    


/**
 * Reference to a field of type 'PaymentMethod'
 */
export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


/**
 * Reference to a field of type 'PaymentMethod[]'
 */
export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


/**
 * Reference to a field of type 'ExpenseStatus'
 */
export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


/**
 * Reference to a field of type 'ExpenseStatus[]'
 */
export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    


/**
 * Reference to a field of type 'EventType'
 */
export type EnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType'>
    


/**
 * Reference to a field of type 'EventType[]'
 */
export type ListEnumEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventType[]'>
    


/**
 * Reference to a field of type 'EventStatus'
 */
export type EnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus'>
    


/**
 * Reference to a field of type 'EventStatus[]'
 */
export type ListEnumEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EventStatus[]'>
    


/**
 * Reference to a field of type 'DocumentType'
 */
export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


/**
 * Reference to a field of type 'DocumentType[]'
 */
export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


/**
 * Reference to a field of type 'AssetStatus'
 */
export type EnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus'>
    


/**
 * Reference to a field of type 'AssetStatus[]'
 */
export type ListEnumAssetStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AssetStatus[]'>
    


/**
 * Reference to a field of type 'InventoryTransactionType'
 */
export type EnumInventoryTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryTransactionType'>
    


/**
 * Reference to a field of type 'InventoryTransactionType[]'
 */
export type ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryTransactionType[]'>
    


/**
 * Reference to a field of type 'PayrollStatus'
 */
export type EnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus'>
    


/**
 * Reference to a field of type 'PayrollStatus[]'
 */
export type ListEnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus[]'>
    


/**
 * Reference to a field of type 'PayslipStatus'
 */
export type EnumPayslipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipStatus'>
    


/**
 * Reference to a field of type 'PayslipStatus[]'
 */
export type ListEnumPayslipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayslipStatus[]'>
    


/**
 * Reference to a field of type 'CheckStatus'
 */
export type EnumCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckStatus'>
    


/**
 * Reference to a field of type 'CheckStatus[]'
 */
export type ListEnumCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CheckStatus[]'>
    


/**
 * Reference to a field of type 'FollowUpType'
 */
export type EnumFollowUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpType'>
    


/**
 * Reference to a field of type 'FollowUpType[]'
 */
export type ListEnumFollowUpTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpType[]'>
    


/**
 * Reference to a field of type 'FollowUpMethod'
 */
export type EnumFollowUpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpMethod'>
    


/**
 * Reference to a field of type 'FollowUpMethod[]'
 */
export type ListEnumFollowUpMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpMethod[]'>
    


/**
 * Reference to a field of type 'FollowUpStatus'
 */
export type EnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus'>
    


/**
 * Reference to a field of type 'FollowUpStatus[]'
 */
export type ListEnumFollowUpStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FollowUpStatus[]'>
    


/**
 * Reference to a field of type 'LeaveType'
 */
export type EnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType'>
    


/**
 * Reference to a field of type 'LeaveType[]'
 */
export type ListEnumLeaveTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveType[]'>
    


/**
 * Reference to a field of type 'LeaveStatus'
 */
export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


/**
 * Reference to a field of type 'LeaveStatus[]'
 */
export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


/**
 * Reference to a field of type 'PrayerRequestCategory'
 */
export type EnumPrayerRequestCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestCategory'>
    


/**
 * Reference to a field of type 'PrayerRequestCategory[]'
 */
export type ListEnumPrayerRequestCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestCategory[]'>
    


/**
 * Reference to a field of type 'PrayerRequestStatus'
 */
export type EnumPrayerRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestStatus'>
    


/**
 * Reference to a field of type 'PrayerRequestStatus[]'
 */
export type ListEnumPrayerRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestStatus[]'>
    


/**
 * Reference to a field of type 'PrayerRequestPrivacy'
 */
export type EnumPrayerRequestPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestPrivacy'>
    


/**
 * Reference to a field of type 'PrayerRequestPrivacy[]'
 */
export type ListEnumPrayerRequestPrivacyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrayerRequestPrivacy[]'>
    


/**
 * Reference to a field of type 'SurveyStatus'
 */
export type EnumSurveyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyStatus'>
    


/**
 * Reference to a field of type 'SurveyStatus[]'
 */
export type ListEnumSurveyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SurveyStatus[]'>
    


/**
 * Reference to a field of type 'QuestionType'
 */
export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


/**
 * Reference to a field of type 'QuestionType[]'
 */
export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


/**
 * Reference to a field of type 'WorkflowStatus'
 */
export type EnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus'>
    


/**
 * Reference to a field of type 'WorkflowStatus[]'
 */
export type ListEnumWorkflowStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowStatus[]'>
    


/**
 * Reference to a field of type 'WorkflowTriggerType'
 */
export type EnumWorkflowTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowTriggerType'>
    


/**
 * Reference to a field of type 'WorkflowTriggerType[]'
 */
export type ListEnumWorkflowTriggerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowTriggerType[]'>
    


/**
 * Reference to a field of type 'WorkflowActionType'
 */
export type EnumWorkflowActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowActionType'>
    


/**
 * Reference to a field of type 'WorkflowActionType[]'
 */
export type ListEnumWorkflowActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkflowActionType[]'>
    


/**
 * Reference to a field of type 'FormStatus'
 */
export type EnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus'>
    


/**
 * Reference to a field of type 'FormStatus[]'
 */
export type ListEnumFormStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FormStatus[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}


export type Datasource = {
  url?: string
}
export type Datasources = {
  db?: Datasource
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasources?: Datasources
  /**
   * Overwrites the datasource url from your schema.prisma file
   */
  datasourceUrl?: string
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
   */
  adapter?: runtime.SqlDriverAdapterFactory | null
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
}
export type GlobalOmitConfig = {
  user?: Prisma.UserOmit
  socialLogin?: Prisma.SocialLoginOmit
  userSession?: Prisma.UserSessionOmit
  invitation?: Prisma.InvitationOmit
  authAccount?: Prisma.AuthAccountOmit
  session?: Prisma.SessionOmit
  verificationToken?: Prisma.VerificationTokenOmit
  activityLog?: Prisma.ActivityLogOmit
  campus?: Prisma.CampusOmit
  smallGroup?: Prisma.SmallGroupOmit
  groupMember?: Prisma.GroupMemberOmit
  groupMeeting?: Prisma.GroupMeetingOmit
  groupMeetingRotation?: Prisma.GroupMeetingRotationOmit
  groupMeetingAttendance?: Prisma.GroupMeetingAttendanceOmit
  groupDiscussion?: Prisma.GroupDiscussionOmit
  groupDiscussionReply?: Prisma.GroupDiscussionReplyOmit
  discipleshipClass?: Prisma.DiscipleshipClassOmit
  discipleshipEnrollment?: Prisma.DiscipleshipEnrollmentOmit
  mentorship?: Prisma.MentorshipOmit
  mentorshipMeeting?: Prisma.MentorshipMeetingOmit
  announcement?: Prisma.AnnouncementOmit
  announcementRead?: Prisma.AnnouncementReadOmit
  notification?: Prisma.NotificationOmit
  messageTemplate?: Prisma.MessageTemplateOmit
  servicePlan?: Prisma.ServicePlanOmit
  servicePlanItem?: Prisma.ServicePlanItemOmit
  serviceAssignment?: Prisma.ServiceAssignmentOmit
  media?: Prisma.MediaOmit
  livestream?: Prisma.LivestreamOmit
  livestreamChat?: Prisma.LivestreamChatOmit
  livestreamAnalytics?: Prisma.LivestreamAnalyticsOmit
  attendance?: Prisma.AttendanceOmit
  donation?: Prisma.DonationOmit
  givingQRCode?: Prisma.GivingQRCodeOmit
  recurringDonation?: Prisma.RecurringDonationOmit
  expense?: Prisma.ExpenseOmit
  budget?: Prisma.BudgetOmit
  account?: Prisma.AccountOmit
  transaction?: Prisma.TransactionOmit
  event?: Prisma.EventOmit
  eventRegistration?: Prisma.EventRegistrationOmit
  eventCheckIn?: Prisma.EventCheckInOmit
  calendarEvent?: Prisma.CalendarEventOmit
  facility?: Prisma.FacilityOmit
  facilityBooking?: Prisma.FacilityBookingOmit
  volunteerRole?: Prisma.VolunteerRoleOmit
  volunteerAssignment?: Prisma.VolunteerAssignmentOmit
  volunteerShift?: Prisma.VolunteerShiftOmit
  childrenClass?: Prisma.ChildrenClassOmit
  childrenMinistryMember?: Prisma.ChildrenMinistryMemberOmit
  childrenAttendance?: Prisma.ChildrenAttendanceOmit
  childrenLesson?: Prisma.ChildrenLessonOmit
  youthGroup?: Prisma.YouthGroupOmit
  youthGroupMember?: Prisma.YouthGroupMemberOmit
  youthEvent?: Prisma.YouthEventOmit
  outreach?: Prisma.OutreachOmit
  outreachParticipant?: Prisma.OutreachParticipantOmit
  outreachTestimony?: Prisma.OutreachTestimonyOmit
  communityProject?: Prisma.CommunityProjectOmit
  projectDonation?: Prisma.ProjectDonationOmit
  projectUpdate?: Prisma.ProjectUpdateOmit
  document?: Prisma.DocumentOmit
  asset?: Prisma.AssetOmit
  assetMaintenance?: Prisma.AssetMaintenanceOmit
  department?: Prisma.DepartmentOmit
  inventoryItem?: Prisma.InventoryItemOmit
  inventoryTransaction?: Prisma.InventoryTransactionOmit
  staff?: Prisma.StaffOmit
  payroll?: Prisma.PayrollOmit
  payslip?: Prisma.PayslipOmit
  check?: Prisma.CheckOmit
  guestVisit?: Prisma.GuestVisitOmit
  guestFollowUp?: Prisma.GuestFollowUpOmit
  leave?: Prisma.LeaveOmit
  performanceAppraisal?: Prisma.PerformanceAppraisalOmit
  church?: Prisma.ChurchOmit
  churchSetting?: Prisma.ChurchSettingOmit
  customField?: Prisma.CustomFieldOmit
  residence?: Prisma.ResidenceOmit
  prayerRequest?: Prisma.PrayerRequestOmit
  prayer?: Prisma.PrayerOmit
  prayerRequestUpdate?: Prisma.PrayerRequestUpdateOmit
  conversation?: Prisma.ConversationOmit
  conversationParticipant?: Prisma.ConversationParticipantOmit
  message?: Prisma.MessageOmit
  messageRead?: Prisma.MessageReadOmit
  survey?: Prisma.SurveyOmit
  surveyQuestion?: Prisma.SurveyQuestionOmit
  surveyResponse?: Prisma.SurveyResponseOmit
  surveyResponseAnswer?: Prisma.SurveyResponseAnswerOmit
  memberEngagementScore?: Prisma.MemberEngagementScoreOmit
  workflow?: Prisma.WorkflowOmit
  workflowAction?: Prisma.WorkflowActionOmit
  workflowExecution?: Prisma.WorkflowExecutionOmit
  workflowActionExecution?: Prisma.WorkflowActionExecutionOmit
  form?: Prisma.FormOmit
  formField?: Prisma.FormFieldOmit
  formSubmission?: Prisma.FormSubmissionOmit
  formSubmissionAnswer?: Prisma.FormSubmissionAnswerOmit
  memberConnection?: Prisma.MemberConnectionOmit
  casbinRule?: Prisma.CasbinRuleOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

